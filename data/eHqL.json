{"name":"eHqL","title":"[library] MicroGL","description":"<div class=\"markdown\"><p>uniform &#x3084; attribute &#x306E;&#x578B;&#x3092;&#x4F55;&#x56DE;&#x3082;&#x5BA3;&#x8A00;&#x3059;&#x308B;&#x306E;&#x3092;&#x3084;&#x3081;&#x305F;&#x3044;&#x3068;&#x601D;&#x3063;&#x3066;&#x304B;&#x304D;&#x307E;&#x3057;&#x305F;</p>\n\n<p><a href=\"http://xl1.github.io/microgl\">http://xl1.github.io/microgl</a> &#x3092;&#x53C2;&#x7167;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;</p>\n\n<p>2012/07/25 CoffeeScript &#x306B;&#x3057;&#x305F;</p>\n\n<p>2012/10/12 &#x30C6;&#x30AF;&#x30B9;&#x30C1;&#x30E3;&#x3092; WebGLTexture &#x4EE5;&#x5916;&#x3067;&#x4E0E;&#x3048;&#x3089;&#x308C;&#x308B;&#x3088;&#x3046;&#x306B;&#x3057;&#x305F;&#x3089;&#x30D0;&#x30B0;&#x3063;&#x3066;&#x305F;&#x306E;&#x3067;&#x76F4;&#x3057;&#x305F;</p>\n\n<p>2012/10/25 &#x30E1;&#x30E2;&#x30EA;&#x30EA;&#x30FC;&#x30AF;&#x3057;&#x3066;&#x305F;&#x306E;&#x3067;&#x76F4;&#x3057;&#x305F;</p>\n\n<p>2013/03/18 updated</p>\n\n<p>2013/06/07 updated</p>\n\n<p>2013/06/19 updated &#x30D6;&#x30EC;&#x30F3;&#x30C9;&#x306E;&#x30B5;&#x30DD;&#x30FC;&#x30C8;&#x8FFD;&#x52A0;</p>\n\n<p>2013/10/01 <a href=\"http://typedarray.org/shaderdsl-js-javascript-based-dsls-for-gpu-shaders/\">ShaderDSL.js</a> &#x306E;&#x30B5;&#x30DD;&#x30FC;&#x30C8;</p>\n</div>","libraries":[],"js":{"language":"coffeescript","content":"RC = WebGLRenderingContext\n\n# uniform type suffix\nTYPESUFFIX = {}\nTYPESUFFIX[RC.FLOAT]        = '1f'\nTYPESUFFIX[RC.FLOAT_VEC2]   = '2fv'\nTYPESUFFIX[RC.FLOAT_VEC3]   = '3fv'\nTYPESUFFIX[RC.FLOAT_VEC4]   = '4fv'\nTYPESUFFIX[RC.INT]          = '1i'\nTYPESUFFIX[RC.INT_VEC2]     = '2iv'\nTYPESUFFIX[RC.INT_VEC3]     = '3iv'\nTYPESUFFIX[RC.INT_VEC4]     = '4iv'\nTYPESUFFIX[RC.BOOL]         = '1i'\nTYPESUFFIX[RC.BOOL_VEC2]    = '2iv'\nTYPESUFFIX[RC.BOOL_VEC3]    = '3iv'\nTYPESUFFIX[RC.BOOL_VEC4]    = '4iv'\nTYPESUFFIX[RC.FLOAT_MAT2]   = 'Matrix2fv'\nTYPESUFFIX[RC.FLOAT_MAT3]   = 'Matrix3fv'\nTYPESUFFIX[RC.FLOAT_MAT4]   = 'Matrix4fv'\nTYPESUFFIX[RC.SAMPLER_2D]   = 'Sampler2D'\nTYPESUFFIX[RC.SAMPLER_CUBE] = 'SamplerCube'\n\n# attribute type sizes\nTYPESIZE = {}\nTYPESIZE[RC.FLOAT]      = 1\nTYPESIZE[RC.FLOAT_VEC2] = 2\nTYPESIZE[RC.FLOAT_VEC3] = 3\nTYPESIZE[RC.FLOAT_VEC4] = 4\nTYPESIZE[RC.FLOAT_MAT2] = 4\nTYPESIZE[RC.FLOAT_MAT3] = 9\nTYPESIZE[RC.FLOAT_MAT4] = 16\n\n\nclass MicroGL\n  constructor: (opt) ->\n    c = document.createElement('canvas')\n    @gl = c.getContext('webgl', opt) or c.getContext('experimental-webgl', opt)\n    @enabled = !!@gl\n    @uniforms = {}\n    @attributes = {}\n    @textures = {}\n    @cache = {}\n\n\n  init: (elem, width=256, height=256) ->\n    @width = @gl.canvas.width = width\n    @height = @gl.canvas.height = height\n    elem?.appendChild(@gl.canvas)\n    @gl.viewport(0, 0, width, height)\n    @gl.clearColor(0, 0, 0, 1)\n    @gl.clearDepth(1)\n    @gl.enable(@gl.DEPTH_TEST)\n    @gl.depthFunc(@gl.LEQUAL)\n    @\n\n\n  _initShader: (type, source) ->\n    shader = @gl.createShader(type)\n    @gl.shaderSource(shader, source)\n    @gl.compileShader(shader)\n    if not @gl.getShaderParameter(shader, @gl.COMPILE_STATUS)\n      console.log(@gl.getShaderInfoLog(shader))\n    else\n      shader\n\n  makeProgram: (vsSource, fsSource, uniformTypes, attributeTypes) ->\n    program = @gl.createProgram()\n\n    if ShaderDSL? and (typeof vsSource is 'function')\n      dslarg = {\n        vertexShader: vsSource\n        fragmentShader: fsSource\n        uniforms: uniformTypes\n        attributes: attributeTypes\n      }\n      vsSource = ShaderDSL.compileVertexShader(dslarg)\n      fsSource = ShaderDSL.compileFragmentShader(dslarg)\n\n    @gl.attachShader(program, @_initShader(@gl.VERTEX_SHADER, vsSource))\n    @gl.attachShader(program, @_initShader(@gl.FRAGMENT_SHADER, fsSource))\n    @gl.linkProgram(program)\n    if not @gl.getProgramParameter(program, @gl.LINK_STATUS)\n      console.log(@gl.getProgramInfoLog(program))\n    else\n      program\n\n\n  program: (args...) ->\n    # param:\n    #   {WebGLProgram} program\n    #   {string, string} sources of the shaders\n    #   {function, function, dict of string, dict of string} ShaderDSL arguments\n    program = if args[1] then @makeProgram(args...) else args[0]\n    @uniforms = {}\n    for name in Object.keys @attributes\n      @gl.disableVertexAttribArray(@attributes[name].location)\n    @attributes = {}\n    @_useElementArray = false\n\n    @gl.useProgram(program)\n    for i in [0...@gl.getProgramParameter(program, @gl.ACTIVE_UNIFORMS)] by 1\n      uniform = @gl.getActiveUniform(program, i)\n      name = uniform.name\n      @uniforms[name] = {\n        location: @gl.getUniformLocation(program, name)\n        type: uniform.type\n        size: uniform.size # array length\n        name\n      }\n    for i in [0...@gl.getProgramParameter(program, @gl.ACTIVE_ATTRIBUTES)] by 1\n      attribute = @gl.getActiveAttrib(program, i)\n      name = attribute.name\n      loc = @gl.getAttribLocation(program, name)\n      @gl.enableVertexAttribArray(loc)\n      @attributes[name] = {\n        location: loc\n        type: attribute.type\n        size: attribute.size\n        name\n      }\n    @\n\n\n  blend: (sourceFactor, destFactor) ->\n    sFactor = ('' + sourceFactor).toUpperCase()\n    dFactor = ('' + destFactor).toUpperCase()\n    if destFactor\n      @gl.enable(@gl.BLEND)\n      @gl.blendFunc(@gl[sFactor], @gl[dFactor])\n    else switch sFactor\n      when 'FALSE'  then @gl.disable(@gl.BLEND)\n      when 'TRUE'   then @gl.enable(@gl.BLEND)\n      # compositing\n      when 'CLEAR'            then @blend('ZERO', 'ZERO')\n      when 'COPY'             then @blend('ONE', 'ZERO')\n      when 'DESTINATION'      then @blend('ZERO', 'ONE')\n      when 'SOURCE-OVER'      then @blend('ONE', 'ONE_MINUS_SRC_ALPHA')\n      when 'DESTINATION-OVER' then @blend('ONE_MINUS_DST_ALPHA', 'ONE')\n      when 'SOURCE-IN'        then @blend('DST_ALPHA', 'ZERO')\n      when 'DESTINATION-IN'   then @blend('ZERO', 'SRC_ALPHA')\n      when 'SOURCE-OUT'       then @blend('ONE_MINUS_DST_ALPHA', 'ZERO')\n      when 'DESTINATION-OUT'  then @blend('ZERO', 'ONE_MINUS_SRC_ALPHA')\n      when 'SOURCE-ATOP'      then @blend('DST_ALPHA', 'ONE_MINUS_SRC_ALPHA')\n      when 'DESTINATION-ATOP' then @blend('ONE_MINUS_DST_ALPHA', 'SRC_ALPHA')\n      when 'XOR'\n        @blend('ONE_MINUS_DST_ALPHA', 'ONE_MINUS_SRC_ALPHA')\n      when 'LIGHTER'  then @blend('ONE', 'ONE')\n      # blend\n      when 'MULTIPLY' then @blend('ZERO', 'SRC_COLOR')\n      when 'SCREEN'   then @blend('ONE_MINUS_DST_COLOR', 'ONE')\n      when 'EXCLUSION'\n        @blend('ONE_MINUS_DST_COLOR', 'ONE_MINUS_SRC_COLOR')\n      # other\n      when 'ADD'      then @blend('SRC_ALPHA', 'ONE')\n      when 'DEFAULT'  then @blend('SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA')\n      else console.warn 'unsupported blend mode: ' + sourceFactor\n    @\n\n\n  loadImages: (paths, callback, failCallback) ->\n    if typeof paths is 'string'\n      paths = [paths]\n    left = paths.length\n    error = 0\n    onload = -> --left or callback(imgs...)\n    onerror = -> error++ or failCallback?()\n    imgs = (for path in paths\n      img = document.createElement 'img'\n      img.onload = onload\n      img.onerror = onerror\n      img.src = path\n      img\n    )\n\n  texParameter: (tex, param={}, cube) ->\n    type = if cube then @gl.TEXTURE_CUBE_MAP else @gl.TEXTURE_2D\n    filter = @gl[param.filter ? 'LINEAR']\n    wrap = @gl[param.wrap ? 'CLAMP_TO_EDGE']\n\n    @gl.bindTexture(type, tex)\n    @gl.texParameteri(type, @gl.TEXTURE_MAG_FILTER, filter)\n    @gl.texParameteri(type, @gl.TEXTURE_MIN_FILTER, filter)\n    @gl.texParameteri(type, @gl.TEXTURE_WRAP_S, wrap)\n    @gl.texParameteri(type, @gl.TEXTURE_WRAP_T, wrap)\n    @gl.bindTexture(type, null)\n    @\n\n  texParameterCube: (tex, param) ->\n    @texParameter(tex, param, true)\n\n  _setTexture: (img, tex, empty) ->\n    @gl.bindTexture(@gl.TEXTURE_2D, tex)\n    @gl.pixelStorei(@gl.UNPACK_FLIP_Y_WEBGL, true)\n    if empty\n      @gl.texImage2D(@gl.TEXTURE_2D, 0, @gl.RGBA,\n        img.width, img.height, 0, @gl.RGBA, @gl.UNSIGNED_BYTE, null)\n    else\n      @gl.texImage2D(@gl.TEXTURE_2D, 0, @gl.RGBA, @gl.RGBA, @gl.UNSIGNED_BYTE, img)\n    @gl.bindTexture(@gl.TEXTURE_2D, null)\n    @texParameter(tex)\n\n  _setTextureCube: (imgs, tex, empty) ->\n    @gl.bindTexture(@gl.TEXTURE_CUBE_MAP, tex)\n    # POSITIVE_X 34069\n    # NEGATIVE_X 34070\n    # POSITIVE_Y 34071\n    # NEGATIVE_Y 34072\n    # POSITIVE_Z 34073\n    # NEGATIVE_Z 34074\n    if empty\n      for i in [0...6]\n        @gl.texImage2D(\n          @gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, @gl.RGBA,\n          imgs.width, imgs.height, 0, @gl.RGBA, @gl.UNSIGNED_BYTE, null\n        )\n    else\n      for img, i in imgs\n        @gl.texImage2D(\n          @gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n          0, @gl.RGBA, @gl.RGBA, @gl.UNSIGNED_BYTE, img\n        )\n    @gl.bindTexture(@gl.TEXTURE_CUBE_MAP, null)\n    @texParameterCube(tex)\n\n  texture: (source, tex, callback) ->\n    return source if source instanceof WebGLTexture\n    tex or= @gl.createTexture()\n    if typeof source is 'string'\n      @loadImages source, (img) =>\n        @_setTexture(img, tex)\n        if callback\n          callback(tex)\n        else if @_drawArg\n          @gl.bindTexture(@gl.TEXTURE_2D, tex)\n          @draw(@_drawArg...)\n    else\n      # <img>, <video>, <canvas>, ImageData object, etc.\n      @_setTexture(source, tex)\n    tex\n\n  textureCube: (source, tex, callback) ->\n    return source if source instanceof WebGLTexture\n    tex or= @gl.createTexture()\n    # source should be an array-like object\n    if typeof source[0] is 'string'\n      @loadImages source, (imgs...) =>\n        @_setTextureCube(imgs, tex)\n        if callback\n          callback(tex)\n        else if @_drawArg\n          @gl.bindTexture(@gl.TEXTURE_CUBE_MAP, tex)\n          @draw(@_drawArg...)\n    else\n      @_setTextureCube(source, tex)\n    tex\n\n  variable: (param, useCache) ->\n    obj = {}\n    for name in Object.keys param\n      value = param[name]\n      if uniform = @uniforms[name]\n        switch TYPESUFFIX[uniform.type]\n          when 'Sampler2D'\n            if useCache\n              value = @cache[name] = @texture(value, @cache[name])\n            else\n              value = @texture(value)\n          when 'SamplerCube'\n            if useCache\n              value = @cache[name] = @textureCube(value, @cache[name])\n            else\n              value = @textureCube(value)\n        obj[name] = value\n      else if @attributes[name] or (name is 'INDEX')\n        if not value?\n          obj[name] = null\n          continue\n        if useCache\n          # useCache でかつ cache があるときは createBuffer しない\n          buffer = @cache[name] or= @gl.createBuffer()\n        else\n          buffer = @gl.createBuffer()\n        if name is 'INDEX'\n          @gl.bindBuffer(@gl.ELEMENT_ARRAY_BUFFER, buffer)\n          @gl.bufferData(@gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(value), @gl.STATIC_DRAW)\n        else\n          @gl.bindBuffer(@gl.ARRAY_BUFFER, buffer)\n          @gl.bufferData(@gl.ARRAY_BUFFER, new Float32Array(value), @gl.STATIC_DRAW)\n        buffer.length = value.length\n        obj[name] = buffer\n    obj\n\n\n  _bindUniform: (uniform, value) ->\n    suffix = TYPESUFFIX[uniform.type]\n    if ~suffix.indexOf('Sampler')\n      @textures[uniform.name] = value\n    else if ~suffix.indexOf('Matrix')\n      @gl[\"uniform\" + suffix](uniform.location, false, new Float32Array(value))\n    else\n      @gl[\"uniform\" + suffix](uniform.location, value)\n\n\n  _rebindTexture: ->\n    texIndex = 0\n    for name in Object.keys @uniforms\n      uniform = @uniforms[name]\n      if uniform.type is @gl.SAMPLER_2D\n        type = @gl.TEXTURE_2D\n      else if uniform.type is @gl.SAMPLER_CUBE\n        type = @gl.TEXTURE_CUBE_MAP\n      else continue\n      @gl.activeTexture(@gl['TEXTURE' + texIndex])\n      @gl.bindTexture(type, @textures[name])\n      @gl.uniform1i(uniform.location, texIndex)\n      texIndex++\n    @\n\n\n  _bindAttribute: (attribute, value) ->\n    size = TYPESIZE[attribute.type]\n    @gl.bindBuffer(@gl.ARRAY_BUFFER, value)\n    @gl.vertexAttribPointer(attribute.location, size, @gl.FLOAT, false, 0, 0)\n    @_numArrays = value.length / size\n\n  bind: (obj) ->\n    @_drawArg = undefined\n\n    for name in Object.keys obj\n      value = obj[name]\n      if name is 'INDEX'\n        @gl.bindBuffer(@gl.ELEMENT_ARRAY_BUFFER, value)\n        @_useElementArray = value?\n        @_numElements = value?.length\n      else if uniform = @uniforms[name]\n        @_bindUniform(uniform, value)\n      else if attribute = @attributes[name]\n        @_bindAttribute(attribute, value)\n    @\n\n\n  bindVars: (param) ->\n    @bind @variable(param, true)\n\n\n  frame: (width=@width, height=@height, flags={}) ->\n    # flags =\n    #   color: true\n    #   depth: true\n    #   stencil: false\n    #   cube: false\n    fb = @gl.createFramebuffer()\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, fb)\n    tex = @gl.createTexture()\n    if flags.cube\n      @_setTextureCube({ width, height }, tex, true)\n    else\n      @_setTexture({ width, height }, tex, true)\n      @gl.framebufferTexture2D(\n        @gl.FRAMEBUFFER, @gl.COLOR_ATTACHMENT0, @gl.TEXTURE_2D, tex, 0)\n\n    rb = @gl.createRenderbuffer()\n    @gl.bindRenderbuffer(@gl.RENDERBUFFER, rb)\n    @gl.renderbufferStorage(\n      @gl.RENDERBUFFER, @gl.DEPTH_COMPONENT16, width, height)\n    @gl.framebufferRenderbuffer(\n      @gl.FRAMEBUFFER, @gl.DEPTH_ATTACHMENT, @gl.RENDERBUFFER, rb)\n\n    @gl.bindRenderbuffer(@gl.RENDERBUFFER, null)\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, null)\n\n    fb.color = tex\n    fb\n\n  frameCube: (size=@width, flags={}) ->\n    flags.cube = true\n    @frame(size, size, flags)\n\n\n  draw: (type, num) ->\n    @_rebindTexture()\n    if @_useElementArray\n      num ?= @_numElements\n      @gl.drawElements(@gl[type or 'TRIANGLES'], num, @gl.UNSIGNED_SHORT, 0)\n    else\n      num ?= @_numArrays\n      @gl.drawArrays(@gl[type or 'TRIANGLE_STRIP'], 0, num)\n    @_drawArg = [type, num]\n    @\n\n  drawFrame: (fb, type, num) ->\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, fb)\n    @draw(type, num)\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, null)\n    @\n\n  drawFrameCube: (fb, idx, type, num) ->\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, fb)\n    @gl.framebufferTexture2D(@gl.FRAMEBUFFER, @gl.COLOR_ATTACHMENT0,\n      @gl.TEXTURE_CUBE_MAP_POSITIVE_X + idx, fb.color, 0)\n    @draw(type, num)\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, null)\n    @\n\n  clear: ->\n    @gl.clear(@gl.COLOR_BUFFER_BIT | @gl.DEPTH_BUFFER_BIT)\n    @\n\n  clearFrame: (fb) ->\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, fb)\n    @clear()\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, null)\n    @\n\n  clearFrameCube: (fb, idx) ->\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, fb)\n    @gl.framebufferTexture2D(@gl.FRAMEBUFFER, @gl.COLOR_ATTACHMENT0,\n      @gl.TEXTURE_CUBE_MAP_POSITIVE_X + idx, fb.color, 0)\n    @clear()\n    @gl.bindFramebuffer(@gl.FRAMEBUFFER, null)\n    @\n\n\n  read: ->\n    canv = @gl.canvas\n    width = canv.width\n    height = canv.height\n    array = new Uint8Array(width * height * 4)\n    @gl.readPixels(0, 0, width, height, @gl.RGBA, @gl.UNSIGNED_BYTE, array)\n    array\n\n\nwindow?.MicroGL = MicroGL\n"},"html":{"language":"html","content":""},"css":{"language":"css","content":""},"published":"2013-10-01T19:27:12"}