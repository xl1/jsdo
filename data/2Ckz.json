{"name":"2Ckz","title":"[library] customfiltergl.coffee","description":"<div class=\"markdown\"><h2>&#x4F9D;&#x5B58;</h2>\n\n<ul>\n<li><a href=\"http://jsdo.it/xl1/eHqL\">MicroGL</a></li>\n</ul>\n\n<h2>&#x76EE;&#x7684;</h2>\n\n<ul>\n<li><s>custom filter &#x3092;&#x30C7;&#x30D0;&#x30C3;&#x30B0;&#x3059;&#x308B;</s></li>\n<li>filter &#x306E;&#x4ED5;&#x69D8;&#x3092;&#x7406;&#x89E3;&#x3059;&#x308B;</li>\n<li><s>custom filter &#x3092;&#x30B5;&#x30DD;&#x30FC;&#x30C8;&#x3057;&#x3066;&#x306A;&#x3044;&#x30D6;&#x30E9;&#x30A6;&#x30B6;&#x3067;&#x3082;&#x4F7F;&#x3046;</s></li>\n</ul>\n\n<h2>&#x4E0A;&#x4F4D;&#x4E92;&#x63DB;</h2>\n\n<ul>\n<li><a href=\"http://experiments.hertzen.com/css-shaders/\">http://experiments.hertzen.com/css-shaders/</a></li>\n</ul>\n\n<h2>&#x307E;&#x3060;&#x3067;&#x304D;&#x3066;&#x306A;&#x3044;&#x3068;&#x3053;&#x308D;&#x304C;&#x5C71;&#x307B;&#x3069;&#x3042;&#x308B;</h2>\n\n<ul>\n<li>filter-box &#x4EE5;&#x5916;&#x306E;&#x5EA7;&#x6A19;&#x7CFB;&#x306B;&#x3064;&#x3044;&#x3066;&#x7406;&#x89E3;&#x3057;&#x3066;&#x3044;&#x306A;&#x3044;</li>\n<li><a href=\"http://html2canvas.hertzen.com/\">html2canvas</a> &#x3092;&#x4EFB;&#x610F;&#x3067;&#x5229;&#x7528;&#x3057;&#x3066;&#x8981;&#x7D20;&#x3092;&#x753B;&#x50CF;&#x306B;&#x3057;&#x3066;&#x53D6;&#x308A;&#x8FBC;&#x3081;&#x308B;&#x3088;&#x3046;&#x306B;&#x306A;&#x3089;&#x306A;&#x3044;&#x304B;&#x3069;&#x3046;&#x304B; &#x2192; OK <a href=\"http://jsdo.it/xl1/ahmy\">http://jsdo.it/xl1/ahmy</a></li>\n<li>&#x305D;&#x3082;&#x305D;&#x3082;&#x307E;&#x3060; Chrome &#x306A;&#x3069;&#x306B;&#x3082;&#x5B8C;&#x5168;&#x306B;&#x5B9F;&#x88C5;&#x3055;&#x308C;&#x3066;&#x306A;&#x3044;&#x6C17;&#x304C;&#x3059;&#x308B;&#xFF08;&#x4F7F;&#x3044;&#x65B9;&#x304C;&#x9593;&#x9055;&#x3063;&#x3066;&#x3044;&#x308B;&#x306E;&#x304B;&#x3082;&#x3057;&#x308C;&#x306A;&#x3044;&#x2026;&#x2026;&#xFF09;</li>\n</ul>\n\n<h2>&#x66F4;&#x65B0;</h2>\n\n<ul>\n<li><strong>2012/10/24</strong> hue, saturation, color, luminosity blend mode &#x3092;&#x30B5;&#x30DD;&#x30FC;&#x30C8;</li>\n<li><strong>2013/06/19</strong> MicroGL &#x306E;&#x4ED5;&#x69D8;&#x5909;&#x66F4;&#x306B;&#x3088;&#x308B;</li>\n</ul>\n</div>","libraries":[],"js":{"language":"coffeescript","content":"class ShaderPair\n  find = (str, search, start=0) ->\n    idx = str.indexOf(search, start)\n    if idx is -1 then Infinity else idx\n\n  removeComment = (text) ->\n    i = last = 0\n    while true\n      linecomIdx = find(text, '//', i)\n      blockcomIdx = find(text, '/*', i)\n      if not isFinite(linecomIdx) and not isFinite(blockcomIdx)\n        # no comment left\n        return text\n      if linecomIdx < blockcomIdx\n        # remove line comment\n        i = linecomIdx\n        re = new RegExp(/$/gm)\n        re.lastIndex = i\n        # かならずマッチする\n        re.exec(text)\n        last = re.lastIndex\n      else\n        # remove block comment\n        i = blockcomIdx\n        last = find(text, '*/', i) + 2\n      text = text[0...i] + text[last...]\n    text\n\n  COMPOSITE_FRACTIONS = {\n    clear:            ['0.0', '0.0']\n    copy:             ['1.0', '0.0']\n    destination:      ['0.0', '1.0']\n    source_over:      ['1.0', '1.0 - src.a']\n    destination_over: ['1.0 - dst.a', '1.0']\n    source_in:        ['dst.a', '0.0']\n    destination_in:   ['0.0', 'src.a']\n    source_out:       ['1.0 - dst.a', '0.0']\n    destination_out:  ['0.0', '1.0 - src.a']\n    source_atop:      ['dst.a', '1.0 - src.a']\n    destination_atop: ['1.0 - dst.a', 'src.a']\n    xor:              ['1.0 - dst.a', '1.0 - src.a']\n    lighter:          ['1.0', '1.0']\n  }\n\n  constructor: (\n    vertex, fragment, @_mix=false, @_blend='normal', @_composite='source-atop'\n  ) ->\n    vertex or= '''\n      attribute vec4 a_position;\n      uniform mat4 u_projectionMatrix;\n      void main(){\n        gl_Position = u_projectionMatrix * a_position;\n      }\n    '''\n    fragment or= '''\n      precision mediump float;\n      void main(){}\n    '''\n    @original = { vertex, fragment }\n    @source = { vertex, fragment }\n\n  convert: ->\n    @_removeComment()\n    @_convertShader()\n    @source\n\n  _removeComment: ->\n    @source = {\n      vertex: removeComment(@source.vertex)\n      fragment: removeComment(@source.fragment)\n    }\n\n  _getDeclarations: ->\n    blend = @_blend.replace(/-/g, '_');\n    composite = @_composite.replace(/-/g, '_');\n    [fs, fd] = COMPOSITE_FRACTIONS[composite]\n    \"\"\"\n      varying vec2 INSERTED_v_texCoord;\n      uniform sampler2D INSERTED_u_source;\n      vec4 css_MixColor;\n      mat4 css_ColorMatrix = mat4(1.0);\n\n      vec3 INSERTED_mix_normal(vec3 cs, vec3 cd){\n        return cs;\n      }\n      vec3 INSERTED_mix_multiply(vec3 cs, vec3 cd){\n        return cs * cd;\n      }\n      vec3 INSERTED_mix_screen(vec3 cs, vec3 cd){\n        return cd + cs - cd * cs;\n      }\n      vec3 INSERTED_mix_darken(vec3 cs, vec3 cd){\n        return min(cs, cd);\n      }\n      vec3 INSERTED_mix_lighten(vec3 cs, vec3 cd){\n        return max(cs, cd);\n      }\n      vec3 INSERTED_mix_color_dodge(vec3 cs, vec3 cd){\n        return min(vec3(1.0), cd / (vec3(1.0) - cs));\n      }\n      vec3 INSERTED_mix_color_burn(vec3 cs, vec3 cd){\n        return max(vec3(0.0), vec3(1.0) - (vec3(1.0) - cd) / cs);\n      }\n      vec3 INSERTED_mix_hard_light(vec3 cs, vec3 cd){\n        vec3 color;\n        for(int i = 0; i < 3; i++){\n          if(cs[i] <= 0.5)\n            color[i] = INSERTED_mix_multiply(2.0 * cs, cd)[i];\n          else\n            color[i] = INSERTED_mix_screen(2.0 * cs - 1.0, cd)[i];\n        }\n        return color;\n      }\n      vec3 INSERTED_mix_soft_light(vec3 cs, vec3 cd){\n        vec3 color;\n        for(int i = 0; i < 3; i++){\n          float d;\n          if(cd[i] <= 0.25)\n            d = ((16.0 * cd[i] - 12.0) * cd[i] + 4.0) * cd[i];\n          else\n            d = sqrt(cd[i]);\n          if(cs[i] <= 0.5)\n            color[i] = cd[i] - (1.0 - 2.0 * cs[i]) * cd[i] * (1.0 - cd[i]);\n          else\n            color[i] = cd[i] + (2.0 * cs[i] - 1.0) * (d - cd[i]);\n        }\n        return color;\n      }\n      vec3 INSERTED_mix_overlay(vec3 cs, vec3 cd){\n        return INSERTED_mix_hard_light(cd, cs);\n      }\n      vec3 INSERTED_mix_defference(vec3 cs, vec3 cd){\n        return abs(cs - cd);\n      }\n      vec3 INSERTED_mix_exclusion(vec3 cs, vec3 cd){\n        return cs + cd - 2.0 * cs * cd;\n      }\n\n      float INSERTED_luma(vec3 col){\n        return dot(vec3(0.3, 0.59, 0.11), col);\n      }\n      vec3 INSERTED_rgb2lch(vec3 rgb){\n        float\n          mx = max(max(rgb.r, rgb.g), rgb.b),\n          mn = min(min(rgb.r, rgb.g), rgb.b),\n          luma = INSERTED_luma(rgb),\n          chroma = mx - mn,\n          hue;\n\n        if(mx == rgb.r)\n          hue = mod((rgb.g - rgb.b) / chroma, 6.0);\n        if(mx == rgb.g)\n          hue = (rgb.b - rgb.r) / chroma + 2.0;\n        if(mx == rgb.b)\n          hue = (rgb.r - rgb.g) / chroma + 4.0;\n\n        return vec3(luma, chroma, hue);\n      }\n      vec3 INSERTED_lch2rgb(vec3 lch){\n        float \n          luma = lch.x,\n          chroma = lch.y,\n          hue = lch.z,\n          second = chroma * (1.0 - abs(mod(hue, 2.0) - 1.0));\n        vec3 rgb;\n\n        if(hue < 1.0)\n          rgb = vec3(chroma, second, 0.0); \n        else if(hue < 2.0)\n          rgb = vec3(second, chroma, 0.0); \n        else if(hue < 3.0)\n          rgb = vec3(0.0, chroma, second); \n        else if(hue < 4.0)\n          rgb = vec3(0.0, second, chroma); \n        else if(hue < 5.0)\n          rgb = vec3(second, 0.0, chroma); \n        else\n          rgb = vec3(chroma, 0.0, second); \n        \n        rgb += vec3(luma - INSERTED_luma(rgb));\n        return rgb;\n      }\n\n      vec3 INSERTED_mix_hue(vec3 cs, vec3 cd){\n        vec3 ls = INSERTED_rgb2lch(cs), ld = INSERTED_rgb2lch(cd);\n        return INSERTED_lch2rgb(vec3(ld.x, ld.y, ls.z));\n      }\n      vec3 INSERTED_mix_saturation(vec3 cs, vec3 cd){\n        vec3 ls = INSERTED_rgb2lch(cs), ld = INSERTED_rgb2lch(cd);\n        return INSERTED_lch2rgb(vec3(ld.x, ls.y, ld.z));\n      }\n      vec3 INSERTED_mix_color(vec3 cs, vec3 cd){\n        vec3 ls = INSERTED_rgb2lch(cs), ld = INSERTED_rgb2lch(cd);\n        return INSERTED_lch2rgb(vec3(ld.x, ls.y, ls.z));\n      }\n      vec3 INSERTED_mix_luminosity(vec3 cs, vec3 cd){\n        vec3 ls = INSERTED_rgb2lch(cs), ld = INSERTED_rgb2lch(cd);\n        return INSERTED_lch2rgb(vec3(ls.x, ld.y, ld.z));\n      }\n\n      void INSERTED_setFragColor(){\n        vec4 sourceColor = texture2D(INSERTED_u_source, INSERTED_v_texCoord);\n        vec4 dst = css_ColorMatrix * sourceColor;\n        vec4 src = css_MixColor;\n\n        vec3 rgb = clamp(INSERTED_mix_#{blend}(src.rgb, dst.rgb), 0.0, 1.0);\n        float rs = src.a * #{fs};\n        float rd = dst.a * #{fd};\n        float outa = rs + rd;\n        if(outa == 0.0) gl_FragColor = vec4(0.0);\n        gl_FragColor = vec4(\n          (rs * rgb + rd * dst.rgb) / outa,\n          outa\n        );\n      }\n    \"\"\"\n\n  _convertShader: ->\n    return if not @_mix\n    vertex = removeComment(@source.vertex)\n    # もしすでに a_texCoord が宣言されていれば多重宣言しない\n    if not /attribute\\s+vec2\\s+a_texCoord\\W/.test(vertex)\n      vertex = vertex.replace(\n        /(\\W)(void\\s+main\\W)/,\n        '$1attribute vec2 a_texCoord;\\n$2'\n      )\n    @source = {\n      vertex: vertex.replace(/(\\W)(void\\s+main\\W+?\\{)/, '''\n          $1varying vec2 INSERTED_v_texCoord;\n          $2\n          INSERTED_v_texCoord = a_texCoord;\n        ''')\n      fragment: removeComment(@source.fragment)\n        .replace(\n          /\\Wcss_(MixColor|ColorMatrix)\\W[\\w\\W]*?;/g,\n          '$&\\nINSERTED_setFragColor();'\n        )\n        .replace(\n          /(\\W)(void\\smain\\W+?\\{)/,\n          '$1' + @_getDeclarations() +\n          '$2\\nINSERTED_setFragColor();'\n        )\n    }\n\n\nclass Mesh\n  constructor: (@cols=1, @rows=1, @_box='filter-box', @_detached=false) ->\n    @attributes = {}\n    \n  _makeAttachedAttributes: ->\n    { cols, rows } = @\n    a_position = []\n    a_texCoord = []\n    a_meshCoord = []\n    indices = []\n\n    for i in [0..cols]\n      for j in [0..rows]\n        x = i / cols\n        y = j / rows\n        a_position.push(x - 0.5, y - 0.5, 0, 1)\n        a_texCoord.push(x, y)\n        a_meshCoord.push(x, y)\n        if i and j\n          idx = i + j * (cols + 1)\n          indices.push(idx - 2 - cols, idx - 1 - cols, idx)\n          indices.push(idx - 2 - cols, idx, idx - 1)\n\n    @attributes = { a_position, a_texCoord, a_meshCoord, INDEX: indices }\n\n  _makeDetachedAttributes: ->\n    { cols, rows } = @\n    a_position = []\n    a_texCoord = []\n    a_meshCoord = []\n    a_triangleCoord = []\n\n    for i in [0...cols]\n      for j in [0...rows]\n        for k in [0..5]\n          # Chrome 1271 dev, a_triangleCoord.z が +1 されているようだ\n          a_triangleCoord.push(i, j, k+1)\n          x = if k in [0, 3, 5] then i / cols else (i+1) / cols\n          y = if k in [0, 1, 3] then j / rows else (j+1) / rows\n          a_position.push(x - 0.5, y - 0.5, 0, 1)\n          a_texCoord.push(x, y)\n          a_meshCoord.push(x, y)\n\n    @attributes = { a_position, a_texCoord, a_meshCoord, a_triangleCoord, INDEX: null }\n\n  makeAttributes: ->\n    @[\"_make#{if @_detached then 'De' else 'At'}tachedAttributes\"]()\n\n\nclass CustomFilterGL\n  constructor: (parent=document.body, @width=256, @height=256) ->\n    @gl = new MicroGL\n    @gl.init(parent, @width, @height)\n\n    @canvas = @gl.gl.canvas\n    # CSS Shaders と WebGL では座標系の向きが逆なので反転する\n    st = @canvas.style\n    st.WebkitTransform = st.MozTransform = st.MsTransform = st.transform =\n      'rotateX(180deg)'\n    @variables = {}\n\n  draw: ->\n    vars = {}\n    for own key, value of @variables\n      if (@gl.uniforms[key]) or (@gl.attributes[key]) or (key is 'INDEX')\n        vars[key] = value\n    @gl.bindVars vars\n    @gl.draw('TRIANGLES')\n    @_drawn = true\n    @\n\n  _createTexture: (src) ->\n    canv = document.createElement('canvas')\n    canv.width = src.width or src.offsetWidth\n    canv.height = src.height or src.offsetHeight\n\n    ctx = canv.getContext('2d')\n    # CSS Shaders と WebGL では座標系の向きが逆なので反転する\n    ctx.scale(1, -1)\n    ctx.drawImage(src, 0, -canv.height)\n    canv\n    \n  source: (img) ->\n    @_drawn = false\n    @uniforms { INSERTED_u_source: img }\n    @\n\n  shader: (vertex, fragment, mix, blend, composite) ->\n    @_drawn = false\n    shd = new ShaderPair(arguments...)\n    { vertex, fragment } = shd.convert()\n    @gl.program(vertex, fragment)\n    @\n\n  mesh: (cols, rows, box, detached) ->\n    @_drawn = false\n    msh = new Mesh(arguments...)\n\n    @uniforms {\n      u_projectionMatrix: [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1]\n      u_textureSize: [@width, @height]\n      u_meshBox: [-0.5, -0.5, 1, 1]\n      u_tileSize: [@width / msh.cols, @height / msh.rows]\n      u_meshSize: [msh.cols, msh.rows]\n    }\n\n    for own key, value of msh.makeAttributes()\n      @variables[key] = value\n    @\n\n  uniforms: (param) ->\n    @_drawn = false\n    for own key, value of param\n      if typeof value is 'string'\n        # texture の URL である\n        img = document.createElement('img')\n        img.onload = =>\n          @variables[key] = @_createTexture(img)\n          @draw() if @_drawn\n        img.src = value\n      else if value.length? or typeof value isnt 'object'\n        @variables[key] = value\n      else\n        # 配列ではない、HTML(Image | Video | Canvas)Element とか\n        @variables[key] = @_createTexture(value)\n    @\n\n\nwindow?.CustomFilterGL = CustomFilterGL"},"html":{"language":"html","content":""},"css":{"language":"css","content":""},"published":"2013-06-19T00:58:21"}