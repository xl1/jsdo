{"name":"AibB","title":"[library] MusicElementContext","description":"","libraries":[],"js":{"language":"js","content":"(function(){\n\nvar _AudioContext = window.AudioContext || window.webkitAudioContext;\nif(_AudioContext){\n  window.MusicElementsContext = MusicElementsContext;\n} else return;\n\n\nvar targetColor = '#c44';\nvar sourceColor = '#4c4';\nvar conStyle = { lineWidth: 3, strokeStyle: '#ccc' };\n\nvar targetPoint = {\n  endpoint: 'Dot',\n  paintStyle: { fillStyle: targetColor, radius: 10 },\n  anchor: 'LeftMiddle',\n  isTarget: true,\n  isSource: true,\n  connectorStyle: conStyle,\n  maxConnections: -1\n};\nvar sourcePoint = {\n  endpoint: 'Dot',\n  paintStyle: { fillStyle: sourceColor, radius: 10 },\n  anchor: 'RightMiddle',\n  isTarget: true,\n  isSource: true,\n  connectorStyle: conStyle,\n  maxConnections: -1\n};\n\n(function(){\n  jsPlumb.bind(\"jsPlumbConnection\", connectME);\n  jsPlumb.bind(\"jsPlumbConnectionDetached\", disconnectME);\n  \n  function connectME(e){\n    var p = endpointPair(e.sourceEndpoint, e.targetEndpoint);\n    if(p){\n      $me(p.source).connect($me(p.target));\n    } else {\n      jsPlumb.detach(e.connection);\n    }\n  }\n  function disconnectME(e){\n    var p = endpointPair(e.sourceEndpoint, e.targetEndpoint);\n    if(!p) return;\n    $me(p.source).disconnect();\n    p.source.connections.forEach(function(c){\n      var pp = endpointPair(c.endpoints);\n      $me(pp.source).connect($me(pp.target));\n    });\n  }\n  function $me(endpoint){\n    return endpoint.getElement()[0].parentMusicElement;\n  }\n  function endpointPair(source, target){\n    if(!target){\n      target = source[1]; source = source[0];\n    }\n    // よくない\n    if(source.paintStyle.fillStyle === targetColor){\n      if(target.paintStyle.fillStyle === sourceColor){\n        return { source: target, target: source };\n      } else {\n        return null;\n      }\n    } else if(target.paintStyle.fillStyle === sourceColor){\n      return null;\n    }\n    return { source: source, target: target };\n  }\n})();\n\n\n// --- --- ---\n\n\nfunction MusicElementsContext(parent){\n  var canv = $('<canvas>')\n    .attr({\n      width: 1024,\n      height: 256\n    })\n    .css({\n      width: '100%',\n      height: '100%',\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      'z-index': -1\n    })\n    .appendTo(parent)[0];\n  var cc = canv.getContext('2d');\n  cc.strokeStyle = '#888';\n  \n  var ctx = new _AudioContext();\n  this.parent = _parent;\n  this.addElement = _addElement;\n  \n  function _parent(){ return parent; }\n  function _addElement(x, y, text, type, opt){\n    return new MusicElement(x, y, text, type, opt);\n  }\n  \n  function MusicElement(x, y, text, type, opt){\n    var node = null, rootNode = null;\n    // (input) -> node -> (output)\n    // (input) -> rootNode -> ... -> node -> (output)\n    \n    // create DOM element\n    var elem = $('<div>')\n      .addClass('musicElement')\n      .text(text)\n      .offset({ left: x, top: y })\n      .appendTo(parent);\n    elem[0].parentMusicElement = this;\n    jsPlumb.draggable(elem);\n      \n    // add jsPlumb endpoints\n    var param = {\n   /* typename    : [in, out, func] */ \n      destination : [1, 0, createDestination],\n      audio       : [0, 1, createAudio],\n      sound       : [0, 1, createSound],\n      analyser    : [1, 1, createAnalyser],\n      gain        : [1, 1, createGain],\n      filter      : [1, 1, createFilter],\n      delay       : [1, 1, createDelay],\n      panner      : [1, 1, createPanner],\n//      convolver   : [1, 1, createConvolver], // どうやって使うのかわからない\n      compressor  : [1, 1, createCompressor],\n      'switch'    : [1, 1, createSwitch]\n    }[type];\n    if(!param) return;\n    if(param[0]) this.targetPoint = jsPlumb.addEndpoint(elem, targetPoint);\n    if(param[1]) this.sourcePoint = jsPlumb.addEndpoint(elem, sourcePoint);\n    param[2]();\n    \n    // methods\n    this.getNode = _getNode;\n    //this.getElement = function _getElement(){ return elem; };\n    this.attach = _attach;\n    this.detach = _detach;\n    this.connect = _connect;\n    this.disconnect = _disconnect;\n    this.remove = _remove;\n    \n    \n    function _getNode(){ return rootNode || node; }\n    function _attach(dest){\n      jsPlumb.connect(\n        { source: this.sourcePoint, target: dest.targetPoint }\n      );\n    }\n    function _detach(dest){\n      jsPlumb.detach(\n        { source: this.sourcePoint, target: dest.targetPoint }\n      );\n    }\n    function _connect(dest){ node.connect(dest.getNode()); }\n    function _disconnect(){ node.disconnect(); }\n    function _remove(){ elem.remove(); }\n\n    \n    function createDestination(){\n      node = ctx.destination;\n    }\n    function createAudio(){\n      if(window.MicroMML && 'mml' in opt){\n        node = new MicroMML(opt.mml, ctx).getNode();\n        node.looping = ('looping' in opt) ? opt.looping : true;\n        setTimeout(function(){ node.noteOn(0); }, 1000);\n        return;\n      }\n      node = ctx.createBufferSource();\n      node.looping = ('looping' in opt) ? opt.looping : true;\n      \n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', opt.url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = function(){\n        node.buffer = ctx.createBuffer(xhr.response, false);\n        node.noteOn(0);\n      };\n      xhr.send();\n    }\n    function createSound(){\n      var channel = opt.channel;\n      var len = opt.dataLength;\n      var sampleRate = opt.sampleRate || 44100;\n      \n      node = ctx.createBufferSource();\n      node.looping = ('looping' in opt) ? opt.looping : true;\n      \n      if('data' in opt){\n        // opt.data[] is used\n        channel = channel || opt.data.length;\n        len = len || opt.data[0].length;\n        node.buffer = ctx.createBuffer(channel, len, sampleRate);\n        \n        for(var c = 0; c < opt.data.length; c++){\n          node.buffer.getChannelData(c).set(opt.data[c]);\n        }\n      } else if('dataFunc' in opt) {\n        // create data from opt.dataFunc[]\n        channel = channel || opt.dataFunc.length;\n        node.buffer = ctx.createBuffer(channel, len, sampleRate);\n        \n        for(var c = 0; c < channel; c++){\n          var data = node.buffer.getChannelData(c);\n          for(var i = 0; i < data.length; i++){\n            data[i] = opt.dataFunc[c](i);\n          }\n        }\n      } else return;\n      node.noteOn(0);\n    }\n    function createAnalyser(){\n      rootNode = ctx.createAnalyser();\n      node = ctx.createJavaScriptNode(2048, 1, 1);\n      node.onaudioprocess = function(e){\n        var input = e.inputBuffer.getChannelData(0);\n        //var inputR = e.inputBuffer.getChannelData(1);\n        e.outputBuffer.getChannelData(0).set(input);\n        //e.outputBuffer.getChannelData(1).set(inputR);\n        \n        var data = new Uint8Array(rootNode.frequencyBinCount);\n        if(opt.type === 'freq'){\n          rootNode.getByteFrequencyData(data);\n        } else if(opt.type === 'wave'){\n          rootNode.getByteTimeDomainData(data);\n        }\n        \n        // render data\n        cc.clearRect(0, 0, canv.width, canv.height);\n        cc.beginPath();\n        cc.moveTo(0, 256 - data[0]);\n        for(var i = 1; i < data.length; i++) cc.lineTo(i, 256 - data[i]);\n        cc.stroke();\n      };\n      rootNode.connect(node);\n    }\n    function createGain(){\n      node = ctx.createGainNode();\n      node.gain.value = opt.gain;\n    }\n    function createFilter(){\n      node = ctx.createBiquadFilter();\n      node.type = node[(opt.type || 'ALLPASS').toUpperCase()];\n      if('frequency' in opt) node.frequency.value = opt.frequency;\n      if('Q' in opt)         node.Q.value = opt.Q;\n      if('gain' in opt)      node.gain.value = opt.gain;\n      \n      rootNode = ctx.createJavaScriptNode(2048, 1, 1); // dummy\n      rootNode.onaudioprocess = function(e){\n        var inputL = e.inputBuffer.getChannelData(0);\n        //var inputR = e.inputBuffer.getChannelData(1);\n        e.outputBuffer.getChannelData(0).set(inputL);\n        //e.outputBuffer.getChannelData(1).set(inputR);\n      };\n      rootNode.connect(node);\n    }\n    function createDelay(){\n      node = ctx.createDelayNode();\n      node.delayTime.value = opt.delay;\n    }\n    function createPanner(){\n      node = ctx.createPanner();\n      if('ref' in opt) node.refDistance = opt.ref;\n      if('max' in opt) node.maxDistance = opt.max;\n      ['position', 'orientation', 'velocity'].forEach(function(attr){\n        if(attr in opt)\n          node['set' + attr[0].toUpperCase() + attr.substr(1)]\n            .apply(node, opt[attr]);\n      });\n    }\n    function createCompressor(){\n      // 何をするためのものかよくわからない\n      node = ctx.createDynamicsCompressor();\n    }\n    function createSwitch(){\n      node = ctx.createGainNode();\n      rootNode = ctx.createGainNode();\n      var connected = false;\n      elem.dblclick(function(){\n        if(connected = !connected){\n          rootNode.connect(node);\n        } else {\n          rootNode.disconnect();\n        }\n      }); \n    }\n  }\n}\n\n})();"},"html":{"language":"html","content":""},"css":{"language":"css","content":""},"published":"2012-09-18T12:32:00"}