{"name":"fA1h","title":"forked: Canvas context 2Dで座標変換を実装してみる","description":"","libraries":[],"js":{"language":"coffeescript","content":"# forked from edo_m18's \"Canvas context 2Dで座標変換を実装してみる\" http://jsdo.it/edo_m18/9Xku\ndo (win = window, doc = window.document, exports = window.S3D or (window.S3D = {})) ->\n\n    #Import\n    {max, min, sqrt, tan, cos, sin, PI} = Math\n\n    DEG_TO_RAD = PI / 180\n    ANGLE = PI * 2\n\n# -------------------------------------------------------------------------------\n\n    class Vertex\n        constructor: (@vertecies) ->\n\n        getZPosition: ->\n            ret = 0\n            cnt = 0\n            for v, i in @vertecies by 4\n                cnt++\n                ret += @vertecies[i + 2] * @vertecies[i + 3]\n\n            return ret / cnt\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Vector3 class\n        @constructor\n        @param {number} x Position of x.\n        @param {number} y Position of y.\n        @param {number} z Position of z.\n    ###\n    class Vector3\n        constructor: (@x = 0, @y = 0, @z = 0) ->\n        zero: ->\n            @x = @y = @z = 0;\n\n        equal: (v) ->\n            return (@x is v.x) and (@y is v.y) and (@z is v.z)\n\n        sub: (v) ->\n            @x -= v.x\n            @y -= v.y\n            @z -= v.z\n            return @\n\n        subVectors: (a, b) ->\n            @x = a.x - b.x\n            @y = a.y - b.y\n            @z = a.z - b.z\n            return @\n\n        add: (v) ->\n            @x += v.x\n            @y += v.y\n            @z += v.z\n            return @\n\n        addVectors: (a, b) ->\n            @x = a.x + b.x\n            @y = a.y + b.y\n            @z = a.z + b.z\n            return @\n\n        copy: (v) ->\n            @x = v.x\n            @y = v.y\n            @z = v.z\n            return @\n\n        norm: ->\n            sqrt(@x * @x + @y * @y + @z * @z)\n\n        normalize: ->\n            nrm = @norm()\n\n            if nrm isnt 0\n                nrm = 1 / nrm\n                @x *= nrm\n                @y *= nrm\n                @z *= nrm\n\n            return @\n\n\n        multiply: (v) ->\n            @x *= v.x\n            @y *= v.y\n            @z *= v.z\n\n            return @\n\n        #scalar multiplication\n        multiplyScalar: (s) ->\n            @x *= s\n            @y *= s\n            @z *= s\n            return @\n\n        multiplyVectors: (a, b) ->\n            @x = a.x * b.x\n            @y = a.y * b.y\n            @z = a.z * b.z\n\n        #dot product\n        dot: (v) ->\n            return @x * v.x + @y * v.y + @z * v.z\n\n        cross: (v, w) ->\n\n            return @crossVectors(v, w) if w\n\n            x = @x\n            y = @y\n            z = @z\n\n            @x = (y * v.z) - (z * v.y)\n            @y = (z * v.x) - (x * v.z)\n            @z = (x * v.y) - (y * v.x)\n\n            return @\n\n        #cross product\n        crossVectors: (v, w) ->\n            @x = (w.y * v.z) - (w.z * v.y)\n            @y = (w.z * v.x) - (w.x * v.z)\n            @z = (w.x * v.y) - (w.y * v.x)\n\n            return @\n\n        applyMatrix4: (m) ->\n            e = m.elements\n\n            x = @x\n            y = @y\n            z = @z\n\n            @x = e[0] * x + e[4] * y + e[8]  * z + e[12]\n            @y = e[1] * x + e[5] * y + e[9]  * z + e[13]\n            @z = e[2] * x + e[5] * y + e[10] * z + e[14]\n\n            return @\n\n        ###*\n            射影投影座標変換\n\n            計算された座標変換行列をスクリーンの座標系に変換するために計算する\n            基本はスケーリング（&Y軸反転）と平行移動。\n            行列で表すと\n            w = width  / 2\n            h = height / 2\n            とすると\n                        |w  0  0  0|\n            M(screen) = |0 -h  0  0|\n                        |0  0  1  0|\n                        |w  h  0  1|\n\n            4x4の変換行列を対象の1x4行列[x, y, z, 1]に適用する\n            1x4行列と4x4行列の掛け算を行う\n\n            |@_11 @_12 @_13 @_14|   |x|\n            |@_21 @_22 @_23 @_24| x |y|\n            |@_31 @_32 @_33 @_34|   |z|\n            |@_41 @_42 @_43 @_44|   |1|\n\n            @_4nは1x4行列の最後が1のため、ただ足すだけになる\n\n            @param {Array.<number>} out\n            @param {number} x\n            @param {number} y\n            @param {number} z\n        ###\n        applyProjection: (m, out) ->\n\n            x = @x\n            y = @y\n            z = @z\n\n            e = m.elements\n\n            #Perspective divide\n            w = (e[3] * x + e[7] * y + e[11] * z + e[15])\n\n            _w = Math.abs(1 / w)\n            _x = (e[0] * x + e[4] * y + e[8]  * z + e[12])\n            _y = (e[1] * x + e[5] * y + e[9]  * z + e[13])\n            _z = (e[2] * x + e[6] * y + e[10] * z + e[14])\n\n            @x = _x * _w\n            @y = _y * _w\n            @z = _z * _w\n\n            out[0] = @\n            out[1] = w\n\n            return (-w <= _x <= w) or (-w <= _y <= w) or (-w <= _z <= w)\n\n        clone: ->\n            vec3 = new Vector3\n            vec3.copy @\n            return vec3\n\n        toArray: ->\n            return [@x, @y, @z]\n\n        toString: ->\n            \"#{@x},#{@y},#{@z}\"\n\n\n# -------------------------------------------------------------------\n\n    ###*\n        Matrix2 class\n        @constructor\n    ###\n    class Matrix2\n        constructor: (m11 = 1, m12 = 0, m21 = 0, m22 = 1) ->\n\n            @elements = te = new Float32Array 4\n\n            # |1 0|\n            # |0 1|\n            # ----------\n            # |m11 m12|\n            # |m21 m22|\n            # の行列で初期化\n\n            te[0] = m11; te[2] = m12;\n            te[1] = m21; te[3] = m22;\n\n        ###*\n            逆行列を生成\n            \n            [逆行列の公式]\n\n            A = |a b|\n                |c d|\n\n            について、detA = ad - bc ≠0のときAの逆行列が存在する\n\n            A^-1 = | d -b| * 1 / detA\n                   |-c  a|\n        ###\n        getInvert: ->\n            out = new Matrix2()\n            oe  = out.elements\n            te  = @elements\n\n            det = te[0] * te[3] - te[2] * te[1]\n\n            return null if 0.0001 > det > -0.0001\n\n            oe[0] =  te[3] / det\n            oe[1] = -te[1] / det\n            oe[2] = -te[2] / det\n            oe[3] =  te[0] / det\n\n            return out\n\n# -----------------------------------------------------------\n\n    ###*\n        Matrix4 class\n        @constructor\n        @param {boolean} cpy\n    ###\n    class Matrix4\n        constructor: (cpy) ->\n            @elements = new Float32Array 16\n            if (cpy) then @copy cpy else @identity()\n\n        identity: ->\n\n            # 以下のように初期化\n            # |1 0 0 0|\n            # |0 1 0 0|\n            # |0 0 1 0|\n            # |0 0 0 1|\n            #\n            # |m11 m12 m13 m14|\n            # |m21 m22 m23 m24|\n            # |m31 m32 m33 m34|\n            # |m41 m42 m43 m44|\n            #\n            # OpenGLでは以下の一次元配列となる（縦横に注意）\n            # |m[0] m[4] m[8]  m[12]|\n            # |m[1] m[5] m[9]  m[13]|\n            # |m[2] m[6] m[10] m[14]|\n            # |m[3] m[7] m[11] m[15]|\n\n            te = @elements\n\n            te[0] = 1; te[4] = 0; te[8]  = 0; te[12] = 0;\n            te[1] = 0; te[5] = 1; te[9]  = 0; te[13] = 0;\n            te[2] = 0; te[6] = 0; te[10] = 1; te[14] = 0;\n            te[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;\n\n            return @\n\n        equal: (m) ->\n            te = @elements\n            me = m.elements\n\n            return (\n                (te[0] is me[0]) and (te[4] is me[4]) and (te[8]  is me[8] ) and (te[12] is me[12]) and\n                (te[1] is me[1]) and (te[5] is me[5]) and (te[9]  is me[9] ) and (te[13] is me[13]) and\n                (te[2] is me[2]) and (te[6] is me[6]) and (te[10] is me[10]) and (te[14] is me[14]) and\n                (te[3] is me[3]) and (te[7] is me[7]) and (te[11] is me[11]) and (te[15] is me[15])\n            )\n\n        getInvert: ->\n            out = new Matrix4\n            oe  = out.elements\n            te  = @elements\n\n            a11 = te[0]; a12 = te[4]; a13 = te[8];  a14 = te[12];\n            a21 = te[1]; a22 = te[5]; a23 = te[9];  a24 = te[13];\n            a31 = te[2]; a32 = te[6]; a33 = te[10]; a34 = te[14];\n            a41 = te[3]; a42 = te[7]; a43 = te[11]; a44 = te[15];\n\n            det = (a11 * a22 * a33 * a44\n            + a11 * a23 * a34 * a42\n            + a11 * a24 * a32 * a43\n            + a12 * a21 * a34 * a43\n            + a12 * a23 * a31 * a44\n            + a12 * a24 * a33 * a41\n            + a13 * a21 * a32 * a44\n            + a13 * a22 * a34 * a41\n            + a13 * a24 * a31 * a42\n            + a14 * a21 * a33 * a42\n            + a14 * a22 * a31 * a43\n            + a14 * a23 * a32 * a41\n            - a11 * a22 * a34 * a43\n            - a11 * a23 * a32 * a44\n            - a11 * a24 * a33 * a42\n            - a12 * a21 * a33 * a44\n            - a12 * a23 * a34 * a41\n            - a12 * a24 * a31 * a43\n            - a13 * a21 * a34 * a42\n            - a13 * a22 * a31 * a44\n            - a13 * a24 * a32 * a41\n            - a14 * a21 * a32 * a43\n            - a14 * a22 * a33 * a41\n            - a14 * a23 * a31 * a42)\n\n            return null if 0.0001 > det > -0.0001\n\n            b11 = ((a22 * a33 * a44) + (a23 * a34 * a42) + (a24 * a32 * a43) - (a22 * a34 * a43) - (a23 * a32 * a44) - (a24 * a33 * a42)) / det\n            b12 = ((a12 * a34 * a43) + (a13 * a32 * a44) + (a14 * a33 * a42) - (a12 * a33 * a44) - (a13 * a34 * a42) - (a14 * a32 * a43)) / det\n            b13 = ((a12 * a23 * a44) + (a13 * a24 * a42) + (a14 * a22 * a43) - (a12 * a24 * a43) - (a13 * a22 * a44) - (a14 * a23 * a42)) / det\n            b14 = ((a12 * a24 * a33) + (a13 * a22 * a34) + (a14 * a23 * a32) - (a12 * a23 * a34) - (a13 * a24 * a32) - (a14 * a22 * a33)) / det\n\n            b21 = ((a21 * a34 * a43) + (a23 * a31 * a44) + (a24 * a33 * a41) - (a21 * a33 * a44) - (a23 * a34 * a41) - (a24 * a31 * a43)) / det\n            b22 = ((a11 * a33 * a44) + (a13 * a34 * a41) + (a14 * a31 * a43) - (a11 * a34 * a43) - (a13 * a31 * a44) - (a14 * a33 * a41)) / det\n            b23 = ((a11 * a24 * a43) + (a13 * a21 * a44) + (a14 * a23 * a41) - (a11 * a23 * a44) - (a13 * a24 * a41) - (a14 * a21 * a43)) / det\n            b24 = ((a11 * a23 * a34) + (a13 * a24 * a31) + (a14 * a21 * a33) - (a11 * a24 * a33) - (a13 * a21 * a34) - (a14 * a23 * a31)) / det\n\n            b31 = ((a21 * a32 * a44) + (a22 * a34 * a41) + (a24 * a31 * a42) - (a21 * a34 * a42) - (a22 * a31 * a44) - (a24 * a32 * a41)) / det\n            b32 = ((a11 * a34 * a42) + (a12 * a31 * a44) + (a14 * a32 * a41) - (a11 * a32 * a44) - (a12 * a34 * a41) - (a14 * a31 * a42)) / det\n            b33 = ((a11 * a22 * a44) + (a12 * a24 * a41) + (a14 * a21 * a42) - (a11 * a24 * a42) - (a12 * a21 * a44) - (a14 * a22 * a41)) / det\n            b34 = ((a11 * a24 * a32) + (a12 * a21 * a34) + (a14 * a22 * a31) - (a11 * a22 * a34) - (a12 * a24 * a31) - (a14 * a21 * a32)) / det\n\n            b41 = ((a21 * a33 * a42) + (a22 * a31 * a43) + (a23 * a32 * a41) - (a21 * a32 * a43) - (a22 * a33 * a41) - (a23 * a31 * a42)) / det\n            b42 = ((a11 * a32 * a43) + (a12 * a33 * a41) + (a13 * a31 * a42) - (a11 * a33 * a42) - (a12 * a31 * a43) - (a13 * a32 * a41)) / det\n            b43 = ((a11 * a23 * a42) + (a12 * a21 * a43) + (a13 * a22 * a41) - (a11 * a22 * a43) - (a12 * a23 * a41) - (a13 * a21 * a42)) / det\n            b44 = ((a11 * a22 * a33) + (a12 * a23 * a31) + (a13 * a21 * a32) - (a11 * a23 * a32) - (a12 * a21 * a33) - (a13 * a22 * a31)) / det\n\n            oe[0] = b11; oe[4] = b12; oe[8]  = b13; oe[12] = b14;\n            oe[1] = b21; oe[5] = b22; oe[9]  = b23; oe[13] = b24;\n            oe[2] = b31; oe[6] = b32; oe[10] = b33; oe[14] = b34;\n            oe[3] = b41; oe[7] = b42; oe[11] = b43; oe[15] = b44;\n\n            return out\n\n\n        ###*\n            Copy from `m`\n            @param {Matrix4} m\n        ###\n        copy: (m) ->\n        \n            @elements = m.elements.subarray()\n            return @\n\n        makeFrustum: (left, right, bottom, top, near, far) ->\n\n            te = @elements\n            vw = right - left\n            vh = top - bottom\n\n            x = 2 * near / vw\n            y = 2 * near / vh\n\n            a = (right + left) / (right - left)\n            b = (top + bottom) / (top - bottom)\n            c = - (far + near) / (far - near)\n            d = - (2 * near * far) / (far - near)\n\n\n            # W値用の値を算出\n            #\n            # Z座標は、ニアクリップ面では z/w = -1、\n            # ファークリップ面では z/w = 1 になるように\n            # バイアスされ、スケーリングされる。\n            te[0]  = x; te[4] = 0; te[8]  =  a; te[12] = 0;\n            te[1]  = 0; te[5] = y; te[9]  =  b; te[13] = 0;\n            te[2]  = 0; te[6] = 0; te[10] =  c; te[14] = d;\n            te[3]  = 0; te[7] = 0; te[11] = -1; te[15] = 0;\n\n            return @\n\n\n        perspectiveLH: (fov, aspect, near, far) ->\n            tmp = Matrix4.perspectiveLH(fov, aspect, near, far)\n            @copy tmp\n\n        @perspectiveLH: (fov, aspect, near, far) ->\n\n            tmp = new Matrix4\n            te  = tmp.elements\n\n            ymax = near * tan(fov * DEG_TO_RAD * 0.5)\n            ymin = -ymax\n            xmin = ymin * aspect\n            xmax = ymax * aspect\n\n            return tmp.makeFrustum xmin, xmax, ymin, ymax, near, far\n\n        multiply: (A) ->\n            tmp = Matrix4.multiply(@, A)\n            @copy tmp\n\n            return @\n\n\n        # multiplication\n        # ABふたつの行列の掛け算した結果をthisに保存\n        @multiply: (A, B) ->\n\n            ae = A.elements\n            be = B.elements\n\n            A11 = ae[0]; A12 = ae[4]; A13 = ae[8];  A14 = ae[12];\n            A21 = ae[1]; A22 = ae[5]; A23 = ae[9];  A24 = ae[13];\n            A31 = ae[2]; A32 = ae[6]; A33 = ae[10]; A34 = ae[14];\n            A41 = ae[3]; A42 = ae[7]; A43 = ae[11]; A44 = ae[15];\n\n            B11 = be[0]; B12 = be[4]; B13 = be[8];  B14 = be[12];\n            B21 = be[1]; B22 = be[5]; B23 = be[9];  B24 = be[13];\n            B31 = be[2]; B32 = be[6]; B33 = be[10]; B34 = be[14];\n            B41 = be[3]; B42 = be[7]; B43 = be[11]; B44 = be[15];\n\n            tmp = new Matrix4\n            te  = tmp.elements\n\n            te[0]  = A11 * B11 + A12 * B21 + A13 * B31 + A14 * B41\n            te[4]  = A11 * B12 + A12 * B22 + A13 * B32 + A14 * B42\n            te[8]  = A11 * B13 + A12 * B23 + A13 * B33 + A14 * B43\n            te[12] = A11 * B14 + A12 * B24 + A13 * B34 + A14 * B44\n\n            te[1]  = A21 * B11 + A22 * B21 + A23 * B31 + A24 * B41\n            te[5]  = A21 * B12 + A22 * B22 + A23 * B32 + A24 * B42\n            te[9]  = A21 * B13 + A22 * B23 + A23 * B33 + A24 * B43\n            te[13] = A21 * B14 + A22 * B24 + A23 * B34 + A24 * B44\n\n            te[2]  = A31 * B11 + A32 * B21 + A33 * B31 + A34 * B41\n            te[6]  = A31 * B12 + A32 * B22 + A33 * B32 + A34 * B42\n            te[10] = A31 * B13 + A32 * B23 + A33 * B33 + A34 * B43\n            te[14] = A31 * B14 + A32 * B24 + A33 * B34 + A34 * B44\n\n            te[3]  = A41 * B11 + A42 * B21 + A43 * B31 + A44 * B41\n            te[7]  = A41 * B12 + A42 * B22 + A43 * B32 + A44 * B42\n            te[11] = A41 * B13 + A42 * B23 + A43 * B33 + A44 * B43\n            te[15] = A41 * B14 + A42 * B24 + A43 * B34 + A44 * B44\n\n            return tmp\n\n        ###*\n            Multiply Matrices\n            A, Bふたつの行列の掛け算した結果をthisに保存\n            @param {Matrix4} A.\n            @param {Matrix4} B.\n        ###\n        multiplyMatrices: (A, B) ->\n            tmp = Matrix4.multiply A, B\n            @copy tmp\n\n            return @\n\n        ###*\n            @param {Vector3} v\n        ###\n        translate: (v) ->\n\n            te = @elements\n            x = v.x\n            y = v.y\n            z = v.z\n\n            te[0] = 1; te[4] = 0; te[8]  = 0; te[12] = x;\n            te[1] = 0; te[5] = 1; te[9]  = 0; te[13] = y;\n            te[2] = 0; te[6] = 0; te[10] = 1; te[14] = z;\n            te[3] = 0; te[7] = 0; te[11] = 0; te[15] = 1;\n\n            return @\n\n        ###*\n            @param {Vector3} eye\n            @param {Vector3} target\n            @param {Vector3} up\n        ###\n        lookAt: do ->\n            #カメラに対してのX, Y, Z軸をそれぞれ定義\n            x = new Vector3\n            y = new Vector3\n            z = new Vector3\n\n            return (eye, target, up) ->\n\n                te = @elements\n\n                z.subVectors(eye, target).normalize()\n                x.crossVectors(z, up).normalize()\n                y.crossVectors(x, z).normalize()\n\n                tx = eye.dot x\n                ty = eye.dot y\n                tz = eye.dot z\n\n                te[0] = x.x; te[4] = x.y; te[8]  = x.z; te[12] = -tx;\n                te[1] = y.x; te[5] = y.y; te[9]  = y.z; te[13] = -ty;\n                te[2] = z.x; te[6] = z.y; te[10] = z.z; te[14] = -tz;\n\n                return @\n\n        ###*\n            @param {number} r Rotate X\n        ###\n        rotationX: (r) ->\n\n            # OpenGLのX軸による回転行列\n            # |1       0      0  0|\n            # |0  cos(r) -sin(r) 0|\n            # |0  sin(r)  cos(r) 0|\n            # |0       0      0  1|\n\n            te = @elements\n            c = cos r\n            s = sin r\n\n            te[0] = 1; te[4] = 0; te[8]  =  0; te[12] = 0;\n            te[1] = 0; te[5] = c; te[9]  = -s; te[13] = 0;\n            te[2] = 0; te[6] = s; te[10] =  c; te[14] = 0;\n            te[3] = 0; te[7] = 0; te[11] =  0; te[15] = 1;\n\n            return @\n\n        ###*\n            @param {number} r Rotate Y\n        ###\n        rotationY: (r) ->\n\n            # OpenGLのY軸による回転行列\n            # | cos(r)  0  sin(r)  0|\n            # |      0  1       0  0|\n            # |-sin(r)  0  cos(r)  0|\n            # |      0  0       0  1|\n            \n            te = @elements\n            c = cos r\n            s = sin r\n\n            te[0] =  c; te[4] = 0; te[8]  = s; te[12] = 0;\n            te[1] =  0; te[5] = 1; te[9]  = 0; te[13] = 0;\n            te[2] = -s; te[6] = 0; te[10] = c; te[14] = 0;\n            te[3] =  0; te[7] = 0; te[11] = 0; te[15] = 1;\n\n            return @\n\n        ###*\n            @param {number} r Rotate Z\n        ###\n        rotationZ: (r) ->\n\n            # OpenGLのZ軸による回転行列\n            # | cos(r) -sin(r)  0  0|\n            # | sin(r)  cos(r)  0  0|\n            # |      0      0   1  0|\n            # |      0      0   0  1|\n\n            te = @elements\n            c = cos r\n            s = sin r\n\n            te[0] = c; te[4] = -s; te[8]  = 0; te[12] = 0;\n            te[1] = s; te[5] =  c; te[9]  = 0; te[13] = 0;\n            te[2] = 0; te[6] =  0; te[10] = 1; te[14] = 0;\n            te[3] = 0; te[7] =  0; te[11] = 0; te[15] = 1;\n\n            return @\n\n        clone: ->\n            tmp = new Matrix4\n            tmp.copy @\n            return tmp\n\n# -------------------------------------------------------------------------------\n\n    class Object3D\n        constructor: ->\n            @parent = null\n            @children = []\n            @vertices = []\n            @position = new Vector3\n            @rotation = new Vector3\n            #@scale = new Vector3 1, 1, 1\n            @up    = new Vector3 0, 1, 0\n\n            @matrixTranslate = new Matrix4\n            @matrixRotation = new Matrix4\n            @matrix = new Matrix4\n            @matrixWorld = new Matrix4\n\n            @updateMatrix()\n\n        updateTranslate: do ->\n            tm = new Matrix4\n            previous = null\n\n            return ->\n                return false if previous and @position.equal previous\n\n                previous = @position.clone()\n                @matrixTranslate = tm.clone().translate(@position)\n\n                return true\n\n        updateRotation: do ->\n            rmx = new Matrix4\n            rmy = new Matrix4\n            rmz = new Matrix4\n            previous = null\n\n            return ->\n\n                return false if previous and @rotation.equal previous\n\n                x = @rotation.x * DEG_TO_RAD\n                y = @rotation.y * DEG_TO_RAD\n                z = @rotation.z * DEG_TO_RAD\n\n                tmp = new Matrix4\n                rmx.rotationX x\n                rmy.rotationY y\n                rmz.rotationZ z\n\n                tmp.multiplyMatrices rmx, rmy\n                tmp.multiply rmz\n\n                previous = @rotation.clone()\n                @matrixRotation = tmp\n\n                return true\n\n        updateMatrix: ->\n\n            updatedRotation = @updateRotation()\n            updatedTranslate = @updateTranslate()\n\n            if updatedRotation or updatedTranslate\n                @matrix.multiplyMatrices @matrixTranslate, @matrixRotation\n\n            c.updateMatrix() for c in @children\n\n        updateMatrixWorld: (force) ->\n            if not @parent\n                @matrixWorld.copy @matrix\n            else\n                @matrixWorld.multiplyMatrices @parent.matrixWorld, @matrix\n\n            c.updateMatrixWorld() for c in @children\n\n        getVerticesByProjectionMatrix: (m) ->\n            ret = []\n            inFrustum = false\n\n            wm = Matrix4.multiply m, @matrixWorld\n            for v in @vertices\n                tmp = []\n                inFrustum = v.clone().applyProjection(wm, tmp) or inFrustum\n                ret = ret.concat(tmp[0].toArray().concat(tmp[1]))\n\n            return if inFrustum then ret else []\n\n        add: (object) ->\n            return null if @ is object\n\n            object.parent?.remove object\n\n            @children.push object\n            object.parent = @\n\n        remove: (object) ->\n            return null if @ is object\n\n            index = @children.indexOf object\n\n            return null if index is -1\n\n            ret = @children.splice index, 1\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Camera class\n        @constructor\n        @param {number} fov Field of view.\n        @param {number} aspect Aspect ratio.\n        @param {number} near Near clip.\n        @param {number} far far clip.\n        @param {Vector3} position Position vector.\n    ###\n    class Camera extends Object3D\n        constructor: (@fov, @aspect, @near, @far, @position = new Vector3(0, 0, 20)) ->\n            super\n\n            @viewMatrix = new Matrix4\n            @projectionMatrix = new Matrix4\n\n        setWorld: (m) ->\n            @matrixWorld = m\n\n        getProjectionMatrix: ->\n            tmp = Matrix4.multiply @projectionMatrix, @viewMatrix\n            return tmp.multiply @matrixWorld\n\n        updateProjectionMatrix: ->\n            @lookAt()\n            @projectionMatrix.perspectiveLH(@fov, @aspect, @near, @far)\n\n        lookAt: do ->\n            m1 = new Matrix4\n\n            return (vector) ->\n                @vector = vector or @vector or new Vector3\n                m1.lookAt @position, @vector, @up\n                @viewMatrix.copy m1\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Line class\n            Line -> Object3D\n        @constructor\n        @param {Vector3} vec1\n        @param {Vector3} vec2\n    ###\n    class Line extends Object3D\n        constructor: (x1, y1, z1, x2, y2, z2, @color = new Color(255, 255, 255, 1)) ->\n            super\n\n            @vertices.push new Vector3 x1, y1, z1\n            @vertices.push new Vector3 x2, y2, z2\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Triangle class\n            Triangle -> Object3D\n        @constructor\n        @param {Array} vertecies\n        @param {Texture} texture\n    ###\n    class Triangle extends Object3D\n        constructor: (vertices, @texture) ->\n            super\n\n            @vertices = []\n            for v, i in vertices by 3\n                vec3 = new Vector3 vertices[i + 0], vertices[i + 1], vertices[i + 2]\n                @vertices.push vec3\n\n        getNormal: do ->\n            a = new Vector3\n            b = new Vector3\n\n            return ->\n                a.subVectors(@vertices[1], @vertices[0])\n                b.subVectors(@vertices[2], @vertices[0])\n\n                return a.clone().cross(b).applyMatrix4(@matrixWorld).normalize()\n        \n# -------------------------------------------------------------------------------\n\n    ###*\n        Face class\n            Face -> Object3D\n        @constructor\n        @param {number} x1\n        @param {number} y1\n        @param {number} x2\n        @param {number} y2\n        @param {Texture} texture1\n        @param {Texture} texture2\n    ###\n    class Face extends Object3D\n        constructor: (x1, y1, x2, y2, texture1, texture2) ->\n            super\n\n            triangle1 = new Triangle([\n                x1, y1, 0\n                x1, y2, 0\n                x2, y1, 0\n            ], texture1)\n\n            @add triangle1\n\n            triangle2 = new Triangle([\n                x1, y2, 0\n                x2, y2, 0\n                x2, y1, 0\n            ], texture2)\n\n            @add triangle2\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Plate class\n            Plate -> Object3D\n        @constructor\n        @param {number} width\n        @param {number} height\n        @param {Texture} texture1\n        @param {Texture} texture2\n    ###\n    class Plate extends Object3D\n        constructor: (width, height, texture1, texture2) ->\n            super\n\n            hw = width  * 0.5\n            hh = height * 0.5\n\n            face1 = new Face -hw, hh, hw, -hh, texture1, texture2\n            face2 = new Face -hw, hh, hw, -hh, texture1, texture2\n            face2.rotation.y = 180\n\n            @add face1\n            @add face2\n\n\n# -------------------------------------------------------------------------------\n\n    ###*\n        Cube class\n        @constructor\n        @param {number} w width.\n        @param {number} h height.\n        @param {number} p profound.\n        @param {number} sx divide as x axis.\n        @param {number} sy divide as y axis.\n        @param {number} sz divide as z axis.\n        @param {<Array.<Texture>} materials texture materials.\n    ###\n    class Cube extends Object3D\n        constructor: (w, h, p, sx = 1, sy = 1, sz = 1, materials) ->\n            super\n\n            w *= 0.5\n            h *= 0.5\n            p *= 0.5\n\n            #TOP\n            topFace = new Face -w, h, w, -h, materials[0], materials[1]\n            topFace.rotation.x = -90\n            topFace.position.y = h\n\n            #BOTTOM\n            bottomFace = new Face -w, h, w, -h, materials[2], materials[3]\n            bottomFace.rotation.x = 90\n            bottomFace.position.y = -h\n\n            #FRONT\n            frontFace = new Face -w, h, w, -h, materials[4], materials[5]\n            frontFace.position.z = p\n\n            #BACK\n            backFace = new Face -w, h, w, -h, materials[6], materials[7]\n            backFace.rotation.y = 180\n            backFace.position.z = -p\n\n            #LEFT\n            leftFace = new Face -p, h, p, -h, materials[8], materials[9]\n            leftFace.rotation.y = -90\n            leftFace.position.x = -w\n\n            #RIGHT\n            rightFace = new Face -p, h, p, -h, materials[10], materials[11]\n            rightFace.rotation.y = 90\n            rightFace.position.x = w\n\n            @add rightFace\n            @add leftFace\n            @add backFace\n            @add frontFace\n            @add bottomFace\n            @add topFace\n\n# -------------------------------------------------------------------------------\n\n    class Texture\n        constructor: (@uv_data, @uv_list) ->\n\n# -------------------------------------------------------------------------------\n\n    #class Particle\n    #    constructor: (@v, @sp = 1, @size = 1000, @r = 255, @g = 255, @b = 255) ->\n    #        @vec = new Vector3 1, 0, 1\n\n    #    update: ->\n    #        p = new Quaternion 0, @v\n\n    #        rad = @sp * DEG_TO_RAD\n\n    #        # rad角の回転クォータニオンとその共役を生成\n    #        q = makeRotatialQuaternion(rad, @vec)\n    #        r = makeRotatialQuaternion(-rad, @vec)\n\n    #        # Quaternionを以下のように計算\n    #        # RPQ (RはQの共役）\n    #        \n    #        p = r.multiply p\n    #        p = p.multiply q\n\n    #        @v = p.v\n\n# -------------------------------------------------------------------------------\n\n    class Color\n        constructor: (r = 0, g = 0, b = 0, @a = 1) ->\n            d = 1 / 255\n            @r = r * d\n            @g = g * d\n            @b = b * d\n\n        copy: (c) ->\n            @r = c.r\n            @g = c.g\n            @b = c.b\n            @a = c.a\n            return @\n\n        add: (c) ->\n            @r = min((@r + c.r), 1)\n            @g = min((@g + c.g), 1)\n            @b = min((@b + c.b), 1)\n            @a = min((@a + c.a), 1)\n            return @\n\n        sub: (c) ->\n            @r = max((@r - c.r), 0)\n            @g = max((@g - c.g), 0)\n            @b = max((@b - c.b), 0)\n            @a = max((@a - c.a), 0)\n            return @\n\n        multiplyScalar: (s) ->\n            @r *= s\n            @g *= s\n            @b *= s\n            @a *= s\n            return @\n\n        clone: ->\n            tmp = new Color\n            tmp.copy @\n            return tmp\n\n        toString: ->\n            r = ~~min(@r * 255, 255)\n            g = ~~min(@g * 255, 255)\n            b = ~~min(@b * 255, 255)\n            a = min(@a, 1)\n\n            return \"rgba(#{r}, #{g}, #{b}, #{a})\"\n\n# -------------------------------------------------------------------------------\n\n    class Light extends Object3D\n        constructor: (@strength) ->\n            super\n\n# -------------------------------------------------------------------------------\n\n    class AmbientLight extends Light\n        constructor: (strength) ->\n            super\n\n# -------------------------------------------------------------------------------\n\n    class DiffuseLight extends Light\n        constructor: (strength, vector) ->\n            super\n\n# -------------------------------------------------------------------------------\n\n    class DirectionalLight extends Light\n        constructor: (strength, @direction) ->\n            super\n\n# -------------------------------------------------------------------------------\n\n    class Scene\n        constructor: ->\n            @lights    = []\n            @materials = []\n\n        add: (material) ->\n\n            if material instanceof Light\n                @lights.push material\n\n            else if material instanceof Object3D\n                @materials.push material\n\n        update: ->\n            for m in @materials\n                m.updateMatrix()\n                m.updateMatrixWorld()\n\n# -------------------------------------------------------------------------------\n\n    class Renderer\n        constructor: (@cv, @clearColor = '#fff') ->\n            @_dummyCv = doc.createElement 'canvas'\n            @_dummyG  = @_dummyCv.getContext '2d'\n            @g = cv.getContext '2d'\n            @w = @_dummyCv.width  = cv.width\n            @h = @_dummyCv.height = cv.height\n\n            @fog      = true\n            @lighting = true\n            @fogColor = @clearColor\n            @fogStart = 200\n            @fogEnd   = 1000\n\n        render: (scene, camera) ->\n            camera.updateProjectionMatrix()\n            matProj = camera.getProjectionMatrix()\n\n            @g.beginPath()\n            @g.fillStyle = @clearColor\n            @g.fillRect 0, 0, @w, @h\n\n            scene.update()\n            lights    = scene.lights\n            vertecies = @getTransformedPoint matProj, scene.materials\n\n            @drawTriangles @g, vertecies, lights, @w, @h\n\n        drawTriangles: (g, vertecies, lights, vw, vh) ->\n\n            fogColor = @fogColor\n            fogStart = @fogStart\n            fogEnd   = @fogEnd\n            fog      = @fog\n            lighting = @lighting\n\n            dcv = @_dummyCv\n            dg  = @_dummyG\n\n            for v, i in vertecies\n\n                img    = v.uvData\n                uvList = v.uvList\n                vertexList = v.vertecies\n                z = v.getZPosition()\n                fogStrength = 0\n                normal = v.normal\n\n                hvw = vw * 0.5\n                hvh = vh * 0.5\n\n                x1 = (vertexList[0] *  hvw) + hvw\n                y1 = (vertexList[1] * -hvh) + hvh\n                z1 =  vertexList[2]\n                w1 =  vertexList[3]\n                x2 = (vertexList[4] *  hvw) + hvw\n                y2 = (vertexList[5] * -hvh) + hvh\n                z2 =  vertexList[6]\n                w2 =  vertexList[7]\n                x3 = (vertexList[8] *  hvw) + hvw\n                y3 = (vertexList[9] * -hvh) + hvh\n                z3 =  vertexList[10]\n                w3 =  vertexList[11]\n\n                if not img\n                    g.save()\n\n                    if fog\n                        fogStrength = ((fogEnd - z) / (fogEnd - fogStart))\n                        fogStrength = 0 if fogStrength < 0\n                        g.globalAlpha = fogStrength\n\n                    g.beginPath()\n                    g.moveTo x1, y1\n                    g.lineTo x2, y2\n                    g.closePath()\n                    g.strokeStyle = v.color.toString()\n                    g.stroke()\n                    g.restore()\n                    continue\n\n                width  = dcv.width  = img.width or img.videoWidth or 0\n                height = dcv.height = img.height or img.videoHeight or 0\n\n                # 変換後のベクトル成分を計算\n                _Ax = x2 - x1\n                _Ay = y2 - y1\n                _Az = z2 - z1\n                _Bx = x3 - x1\n                _By = y3 - y1\n                _Bz = z3 - z1\n\n                # 裏面カリング\n                # 頂点を結ぶ順が反時計回りの場合は「裏面」になり、その場合は描画をスキップ\n                # 裏面かどうかの判定は外積を利用する\n                # 判定は、p1, p2, p3の3点から、p1->p2, p1->p3のベクトルとの外積を利用する。\n                continue if (_Ax * _By) - (_Ay * _Bx) > 0\n\n                # 変換前のベクトル成分を計算\n                Ax = (uvList[2] - uvList[0]) * width\n                Ay = (uvList[3] - uvList[1]) * height\n                Bx = (uvList[4] - uvList[0]) * width\n                By = (uvList[5] - uvList[1]) * height\n\n                # move position from A(Ax, Ay) to _A(_Ax, _Ay)\n                # move position from B(Ax, Ay) to _B(_Bx, _By)\n                # A,Bのベクトルを、_A,_Bのベクトルに変換することが目的。\n                # 変換を達成するには、a, b, c, dそれぞれの係数を導き出す必要がある。\n                #\n                #    ↓まずは公式。アフィン変換の移動以外を考える。\n                #\n                # _Ax = a * Ax + c * Ay\n                # _Ay = b * Ax + d * Ay\n                # _Bx = a * Bx + c * By\n                # _By = b * Bx + d * By\n                #\n                #    ↓上記の公式を行列の計算で表すと以下に。\n                #\n                # |_Ax| = |Ax Ay||a|\n                # |_Bx| = |Bx By||c|\n                #\n                #    ↓a, cについて求めたいのだから、左に掛けているものを「1」にする必要がある。\n                #    　行列を1にするには、逆行列を左から掛ければいいので、両辺に逆行列を掛ける。（^-1は逆行列の意味）\n                #\n                # |Ax Ay|^-1 |_Ax| = |a|\n                # |Bx By|    |_Bx| = |c|\n\n                # 上記の\n                # |Ax Ay|\n                # |Bx By|\n                # を生成\n                m = new Matrix2(Ax, Ay, Bx, By)\n                me = m.elements\n\n                # 逆行列を取得\n                # 上記の\n                # |Ax Ay|^-1\n                # |Bx By|\n                # を生成\n                mi  = m.getInvert()\n\n                # 逆行列が存在しない場合はスキップ\n                continue if not mi\n\n                mie = mi.elements\n\n                a = mie[0] * _Ax + mie[2] * _Bx\n                c = mie[1] * _Ax + mie[3] * _Bx\n                b = mie[0] * _Ay + mie[2] * _By\n                d = mie[1] * _Ay + mie[3] * _By\n\n                # 各頂点座標を元に三角形を作り、それでクリッピング\n                g.save()\n                dg.save()\n\n                dg.drawImage(img, 0, 0)\n\n                if lighting\n                    strength = 0\n                    color = new Color 0, 0, 0, 1\n\n                    for l in lights\n                        if l instanceof AmbientLight\n                            strength += l.strength\n\n                        else if l instanceof DirectionalLight\n                            L = l.direction\n                            N = normal.clone().add(L)\n                            factor = N.dot(L)\n                            strength += l.strength * factor\n                            \n                    color.a -= strength\n\n                    if color.a > 0\n                        dg.fillStyle = color.toString()\n                        dg.fillRect 0, 0, width, height\n\n                if fog\n                    fogStrength = 1 - ((fogEnd - z) / (fogEnd - fogStart))\n                    fogStrength = 0 if fogStrength < 0\n                    dg.globalAlpha = fogStrength\n                    dg.globalCompositeOperation = 'source-over'\n                    dg.fillStyle   = fogColor\n                    dg.fillRect 0, 0, width, height\n\n                g.beginPath()\n                g.moveTo(x1, y1)\n                g.lineTo(x2, y2)\n                g.lineTo(x3, y3)\n                g.closePath()\n\n                if @wireframe\n                    g.strokeStyle = 'rgba(255, 255, 255, 0.5)'\n                    g.stroke()\n\n                g.clip()\n\n                g.transform(a, b, c, d,\n                    x1 - (a * uvList[0] * width + c * uvList[1] * height),\n                    y1 - (b * uvList[0] * width + d * uvList[1] * height))\n                g.drawImage(dcv, 0, 0)\n\n                dg.clearRect 0, 0, width, height\n                dg.restore()\n                g.restore()\n \n\n        getTransformedPoint: (mat, materials) ->\n\n            results = []\n\n            for m in materials\n                if m instanceof Triangle\n                    vertecies = m.getVerticesByProjectionMatrix(mat)\n                    uvData    = m.texture.uv_data\n                    uvList    = m.texture.uv_list\n\n                    vertex = new Vertex vertecies\n                    vertex.uvData = uvData\n                    vertex.uvList = uvList\n\n                    continue if vertex.getZPosition() < 0\n\n                    vertex.normal = m.getNormal()\n                    results.push vertex\n\n                else if m instanceof Line\n                    vertecies = m.getVerticesByProjectionMatrix(mat)\n                    vertex = new Vertex vertecies\n                    vertex.color = m.color\n\n                    continue if vertex.getZPosition() < 0\n\n                    results.push vertex\n\n                else\n                    tmp = @getTransformedPoint mat, m.children\n                    results = results.concat tmp\n\n            results.sort (a, b) ->\n                 b.getZPosition() - a.getZPosition()\n\n            return results\n\n# ---------------------------------------------------------------------\n\n    class Quaternion\n        constructor: (@t = 0, @v) ->\n\n        set: (@t, @v) ->\n\n        multiply: (A) ->\n            return Quaternion.multiply @, A\n\n        @multiply: (A, B) ->\n\n            # Quaternionの掛け算の公式は以下。\n            # ・は内積、×は外積、U, Vはともにベクトル。\n            # ;の左が実部、右が虚部。\n            # A = (a; U) \n            # B = (b; V) \n            # AB = (ab - U・V; aV + bU + U×V)\n\n            Av = A.v\n            Bv = B.v\n\n            # 実部の計算\n            d1 =  A.t * B.t\n            d2 = -Av.x * Bv.x\n            d3 = -Av.y * Bv.y\n            d4 = -Av.z * Bv.z\n            t = parseFloat((d1 + d2 + d3 + d4).toFixed(5))\n\n            # 虚部xの計算\n            d1 = (A.t * Bv.x) + (B.t * Av.x)\n            d2 = (Av.y * Bv.z) - (Av.z * Bv.y)\n            x = parseFloat((d1 + d2).toFixed(5))\n\n            # 虚部yの計算\n            d1 = (A.t * Bv.y) + (B.t * Av.y)\n            d2 = (Av.z * Bv.x) - (Av.x * Bv.z)\n            y = parseFloat((d1 + d2).toFixed(5))\n\n            # 虚部zの計算\n            d1 = (A.t * Bv.z) + (B.t * Av.z)\n            d2 = (Av.x * Bv.y) - (Av.y * Bv.x)\n            z = parseFloat((d1 + d2).toFixed(5))\n\n            return new Quaternion t, new Vector3 x, y, z\n\n    ###*\n        Make rotation quaternion\n        @param {number} radian.\n        @param {Vector3} vector.\n    ###\n    makeRotatialQuaternion = (radian, vector) ->\n    \n        ret = new Quaternion\n        ccc = 0\n        sss = 0\n        axis = new Vector3\n        axis.copy vector\n\n        norm = vector.norm()\n\n        return ret if norm <= 0.0\n\n        axis.normalize()\n\n        ccc = cos(0.5 * radian)\n        sss = sin(0.5 * radian)\n\n        t = ccc\n        axis.multiplyScalar sss\n\n        ret.set t, axis\n\n        return ret\n\n\n    exports.Object3D = Object3D\n    exports.Matrix2  = Matrix2\n    exports.Matrix4  = Matrix4\n    exports.Camera   = Camera\n    exports.Renderer = Renderer\n    exports.Texture  = Texture\n    exports.Triangle = Triangle\n    exports.Scene = Scene\n    exports.Line  = Line\n    exports.Plate = Plate\n    exports.Cube  = Cube\n    exports.Face  = Face\n    #exports.Particle = Particle\n    exports.Texture  = Texture\n    exports.Vector3  = Vector3\n    exports.Color    = Color\n    exports.Quaternion = Quaternion\n    exports.AmbientLight = AmbientLight\n    exports.DirectionalLight = DirectionalLight\n\n    \ndo (win = window, doc = window.document, exports = window) ->\n\n    #Import\n    {tan, cos, sin, PI} = Math\n    {Object3D, Line, Color, AmbientLight, DirectionalLight, Plate, Face, Cube, Texture, Triangle, Matrix4, Camera, Renderer, Scene, Vector3, Particle} = window.S3D\n\n    DEG_TO_RAD = PI / 180\n\n    isTouch = 'ontouchstart' of window\n    MOUSE_DOWN = if isTouch then 'touchstart' else 'mousedown'\n    MOUSE_MOVE = if isTouch then 'touchmove' else 'mousemove'\n    MOUSE_UP   = if isTouch then 'touchend' else 'mouseup'\n\n    textureImage = null\n    logoImage    = null\n    photoImage   = null\n    rotX = 0\n    rotY = 0\n\n    renderer = null\n    camera   = null\n    scene    = null\n\n    getVideo = ->\n\n        video = doc.getElementById 'video'\n        video.autoplay = true\n        video.loop = true\n\n        return video\n\n\n    init = ->\n\n        video = getVideo()\n\n        cv  = doc.getElementById 'canvas'\n        ctx = cv.getContext '2d'\n        w = cv.width  = win.innerWidth\n        h = cv.height = win.innerHeight\n        fov = 60\n        aspect = w / h\n\n        cnt = 3\n        img = new Image()\n        logo = new Image()\n        photo = new Image()\n\n        img.onload = ->\n            textureImage = img\n            --cnt or create()\n\n        logo.onload = ->\n            logoImage = logo\n            --cnt or create()\n\n        photo.onload = ->\n            photoImage = photo\n            --cnt or create()\n\n        photo.src = '../assets/yrAVl.jpg'\n        logo.src = '../assets/z129U.png'\n        img.src = '../assets/kMJJS.png'\n\n        camera = new Camera 40, aspect, 0.1, 10000\n        camera.position.x = 10\n        camera.position.y = 50\n        camera.position.z = 200\n        #camera.up = new Vector3 1, 0, 0\n        camera.lookAt new Vector3 0, 0, 0\n        scene    = new Scene\n        renderer = new Renderer cv, '#111'\n        #renderer.fog      = false\n        #renderer.lighting = false\n        #renderer.wireframe = true\n\n        create = ->\n\n            materials1 = [\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n                new Texture(photoImage, [0, 0, 0, 1, 1, 0])\n                new Texture(photoImage, [0, 1, 1, 1, 1, 0])\n            ]\n\n            materials2 = [\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n                new Texture(video, [0, 0, 0, 1, 1, 0])\n                new Texture(video, [0, 1, 1, 1, 1, 0])\n            ]\n\n            cube1 = new Cube 50, 20, 20, 1, 1, 1, materials2\n            cube1.position.z = -50\n            cube1.rotation.z = 30\n\n            cube2 = new Cube 20, 20, 20, 1, 1, 1, materials1\n            cube2.position.z = -150\n            cube2.position.x = 50\n\n            cube3 = new Cube 20, 20, 20, 1, 1, 1, materials1\n            cube3.position.z = -350\n            cube3.position.x = 50\n            cube3.position.y = 80\n\n            plate1 = new Plate 50, 50, new Texture(textureImage, [0.0, 0.5, 0.0, 1.0, 0.5, 0.5]), new Texture(textureImage, [0.0, 1.0, 0.5, 1.0, 0.5, 0.5])\n            plate1.position.x = -50\n            plate1.position.z = -300\n\n            plate2 = new Plate 50, 50, new Texture(video, [0, 0, 0, 1, 1, 0]), new Texture(video, [0, 1, 1, 1, 1, 0])\n            plate2.position.y = -100\n            plate2.position.z = -500\n\n            line1 = new Line(0, 0, -200, 0, 0, 200, new Color(255, 0, 0, 0.3))\n            line2 = new Line(-200, 0, 0, 200, 0, 0, new Color(0, 255, 0, 0.3))\n            line3 = new Line(0, 200, 0, 0, -200, 0, new Color(0, 0, 255, 0.3))\n\n            size = 300\n            container = new Object3D\n            container.position.x = -(size * 0.5)\n            container.position.z = -(size * 0.5)\n\n            for i in [0..(size / 10)]\n                z = i * 10\n                line = new Line(0, 0, z, size, 0, z, new Color(255, 255, 255, 0.3))\n                container.add line\n\n            for i in [0..(size / 10)]\n                x = i * 10\n                line = new Line(x, 0, 0, x, 0, size, new Color(255, 255, 255, 0.3))\n                container.add line\n\n            ambLight = new AmbientLight(0.1)\n            dirLight = new DirectionalLight(0.8, (new Vector3(-1, 1, 1)).normalize())\n           \n            scene.add ambLight\n            scene.add dirLight\n\n            scene.add plate1\n            scene.add plate2\n            scene.add container\n            scene.add cube1\n            scene.add cube2\n            scene.add cube3\n            scene.add line1\n            scene.add line2\n            scene.add line3\n\n            angle = 0\n\n            do _loop = ->\n                angle = (++angle % 360)\n                plate1.rotation.z = angle\n                plate2.rotation.x = angle * 3\n                cube1.rotation.z = angle\n                cube2.rotation.x = angle * 2\n                cube3.rotation.x = angle * 3\n                cube3.rotation.y = angle * 3\n                cube3.rotation.z = angle * 3\n                renderer.render scene, camera\n                setTimeout _loop, 32\n\n    dragging = false\n    prevX = 0\n    prevY = 0\n\n    # Events\n    win.addEventListener 'mousewheel', (e) ->\n        camera.position.z += (e.wheelDelta / 100)\n        renderer.render scene, camera\n        e.preventDefault()\n    , false\n\n    base = 100\n    startZoom = 0\n    document.addEventListener 'gesturechange', (e) ->\n        num =  e.scale * base - base\n        camera.position.z = startZoom - num\n        renderer.render scene, camera\n        e.preventDefault()\n    , false\n    \n    document.addEventListener 'gesturestart', ->\n        startZoom = camera.position.z\n    , false\n\n    doc.addEventListener 'touchstart', (e) ->\n        e.preventDefault()\n    , false\n\n    doc.addEventListener MOUSE_DOWN, (e) ->\n        dragging = true\n        prevX = if isTouch then e.touches[0].pageX else e.pageX\n        prevY = if isTouch then e.touches[0].pageY else e.pageY\n    , false\n\n    doc.addEventListener MOUSE_MOVE, (e) ->\n        return if dragging is false\n\n        pageX = if isTouch then e.touches[0].pageX else e.pageX\n        pageY = if isTouch then e.touches[0].pageY else e.pageY\n\n        rotY += (prevX - pageX) / 100\n        rotX += (prevY - pageY) / 100\n\n        camera.setWorld(Matrix4.multiply((new Matrix4()).rotationY(rotY), (new Matrix4()).rotationX(rotX)))\n\n        prevX = pageX\n        prevY = pageY\n        \n        renderer.render scene, camera\n    , false\n\n    doc.addEventListener MOUSE_UP, (e) ->\n        dragging = false\n    , false\n\n    doc.addEventListener 'DOMContentLoaded', init, false\n"},"html":{"language":"html","content":"<div>\n    <canvas id=\"canvas\" width=\"400\" height=\"300\"></canvas>\n    <video src=\"http://craftymind.com/factory/html5video/BigBuckBunny_640x360.mp4\" id=\"video\" autoplay style=\"display: none;\"></video>\n</div>"},"css":{"language":"css","content":"* {\n    margin: 0;\n    padding: 0;\n}"},"published":"2013-04-07T13:47:38"}