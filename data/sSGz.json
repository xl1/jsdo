{"name":"sSGz","title":"地形生成","description":"<div class=\"markdown\"><p>CPU &#x3067;&#x306F;&#x3042;&#x307E;&#x308A;&#x8A08;&#x7B97;&#x3057;&#x305F;&#x308A;&#x914D;&#x5217;&#x56DE;&#x3057;&#x305F;&#x308A;&#x3057;&#x306A;&#x3044;&#x3088;&#x3046;&#x306B;&#x3057;&#x3066;&#x308B;</p>\n\n<h3>2013/06/07 &#x66F4;&#x65B0;</h3>\n\n<p>&#x5225;&#x306B;&#x4E00;&#x5EA6;&#x30D5;&#x30EC;&#x30FC;&#x30E0;&#x30D0;&#x30C3;&#x30D5;&#x30A1;&#x306B;&#x63CF;&#x304F;&#x5FC5;&#x8981;&#x306F;&#x306A;&#x304F; 1 &#x30D1;&#x30B9;&#x3067;&#x63CF;&#x3051;&#x305F;&#x306E;&#x3067;&#x305D;&#x3046;&#x3057;&#x305F;</p>\n</div>","libraries":["/xl1/eHqL"],"js":{"language":"coffeescript","content":"# shaders\nvshader = '''\n  attribute vec2 a_position;\n  uniform mat4 u_perspective;\n  uniform vec2 u_origin;\n  varying vec3 v_position;\n\n  float random(vec2 p){\n    return fract(sin(p.x + p.y * 1.3 + 0.1) * 12345.6789);\n  }\n  float noise(vec2 p, float scale){\n    const vec2 D = vec2(0.0, 1.0);\n    vec2 q = p / scale, i = floor(q), f = fract(q);\n    return mix(\n      mix(random(i), random(i + D.yx), smoothstep(0.0, 1.0, f.x)),\n      mix(random(i + D), random(i + D.yy), smoothstep(0.0, 1.0, f.x)),\n      smoothstep(0.0, 1.0, f.y)\n    );\n  }\n\n  void main(){\n    float height = 0.0, scale = 1.0;\n    vec2 p = 256.0 * a_position + u_origin;\n    for(int i = 0; i <= 5; i++){\n      height += scale * noise(p, scale) / 64.0;\n      scale += scale;\n    }\n    gl_Position = u_perspective * vec4(\n      24.0 * a_position.x - 12.0,\n      4.0 * height - 12.0,\n      24.0 * a_position.y + 5.0,\n      1.0\n    );\n    v_position = vec3(a_position, height);\n  }\n'''\n\nfshader = '''\n  precision mediump float;\n  varying vec3 v_position;\n  const vec3 light = vec3(1.0);\n  const vec3 color = vec3(0.3, 0.9, 0.1);\n\n  void main(){\n    gl_FragColor = vec4((1.0 - v_position.y) * v_position.z * color, 1.0);\n  }\n'''\n\ngl = new MicroGL(antialias: false)\nstartT = 0\nsize = 128\n\nmain = ->\n  terrain = []\n  for y in [0...size] by 1\n    terrain.push 0, y / size\n    for x in [0..size] by 1\n      terrain.push(\n        x / size, y / size, x / size, (y + 1) / size\n      )\n    terrain.push 1, (y + 1) / size\n\n  gl.init(document.body)\n    .program(vshader, fshader)\n    .bindVars(\n      a_position: terrain\n      u_perspective: [\n        2, 0.000,  0.000,  0.000\n        0, 1.732, -0.505, -0.500\n        0, 1.000,  0.875,  0.866\n        0, 0.000, -1.010,  0.000\n      ]\n    )\n  startT = Date.now()\n  update()\n\nupdate = ->\n  t = (Date.now() - startT) * 0.1\n  gl.bindVars(u_origin: [0, t]).clear().draw()\n  requestAnimationFrame update\n\nmain()"},"html":{"language":"html","content":""},"css":{"language":"css","content":""},"published":"2013-06-07T22:39:29"}